{"version":3,"sources":["../../src/encryption/index.spec.ts"],"sourcesContent":["import crypto from \"node:crypto\"\n\nimport { describe, expect, it } from \"vitest\"\n\nimport { EncryptionModule } from \"./index\"\n\ndescribe(\"EncryptionModule\", () => {\n\tconst validKey = \"12345678901234567890123456789012\" // ascii string 32 bytes\n\tconst data = new Uint8Array(Buffer.from(\"hello world\"))\n\n\tdescribe(\"aesGcmEncrypt\", () => {\n\t\tit(\"should encrypt data correctly and return ciphertext and nonce\", async () => {\n\t\t\tconst result = await EncryptionModule.aesGcmEncrypt(data, validKey)\n\n\t\t\texpect(result.ciphertext).toBeDefined()\n\t\t\texpect(typeof result.ciphertext).toBe(\"string\")\n\t\t\texpect(result.nonce).toBeDefined()\n\t\t\texpect(result.nonce).toBeInstanceOf(Uint8Array)\n\t\t\texpect(result.nonce.length).toBe(12)\n\t\t})\n\n\t\tit(\"should use provided nonce if given\", async () => {\n\t\t\tconst nonce = crypto.randomBytes(12)\n\t\t\tconst result = await EncryptionModule.aesGcmEncrypt(data, validKey, nonce)\n\n\t\t\texpect(result.nonce).toEqual(new Uint8Array(nonce))\n\t\t})\n\n\t\tit(\"should throw error if key length is invalid\", async () => {\n\t\t\tawait expect(EncryptionModule.aesGcmEncrypt(data, \"invalid-length\")).rejects.toThrow(\n\t\t\t\t\"Encryption key must be exactly 32 bytes for AES-256\",\n\t\t\t)\n\t\t})\n\t})\n\n\tdescribe(\"aesGcmDecrypt\", () => {\n\t\tit(\"should decrypt data correctly\", async () => {\n\t\t\tconst { ciphertext, nonce } = await EncryptionModule.aesGcmEncrypt(data, validKey)\n\n\t\t\tconst decrypted = await EncryptionModule.aesGcmDecrypt(ciphertext, nonce, validKey)\n\n\t\t\texpect(decrypted).toEqual(data)\n\t\t\texpect(Buffer.from(decrypted).toString()).toBe(\"hello world\")\n\t\t})\n\n\t\tit(\"should throw error if key length is invalid\", async () => {\n\t\t\tconst { ciphertext, nonce } = await EncryptionModule.aesGcmEncrypt(data, validKey)\n\n\t\t\tawait expect(EncryptionModule.aesGcmDecrypt(ciphertext, nonce, \"invalid-length\")).rejects.toThrow(\n\t\t\t\t\"Encryption key must be exactly 32 bytes for AES-256\",\n\t\t\t)\n\t\t})\n\n\t\tit(\"should fail to decrypt with wrong key\", async () => {\n\t\t\tconst { ciphertext, nonce } = await EncryptionModule.aesGcmEncrypt(data, validKey)\n\t\t\tconst wrongKey = \"12345678901234567890123456789013\" // 32 bytes different key\n\n\t\t\tawait expect(EncryptionModule.aesGcmDecrypt(ciphertext, nonce, wrongKey)).rejects.toThrow(\n\t\t\t\t\"Failed to decrypt data\",\n\t\t\t)\n\t\t})\n\t})\n\n\tdescribe(\"generateEncryptionKey\", () => {\n\t\tit(\"should generate a 64-character hex key by default (32 bytes)\", () => {\n\t\t\tconst key = EncryptionModule.generateEncryptionKey()\n\t\t\texpect(typeof key).toBe(\"string\")\n\t\t\texpect(key.length).toBe(64) // 32 bytes * 2 hex chars\n\t\t\texpect(/^[0-9a-fA-F]+$/.test(key)).toBe(true)\n\t\t})\n\n\t\tit(\"should generate a 64-character hex key when specified\", () => {\n\t\t\tconst key = EncryptionModule.generateEncryptionKey(\"hex\")\n\t\t\texpect(typeof key).toBe(\"string\")\n\t\t\texpect(key.length).toBe(64)\n\t\t\texpect(/^[0-9a-fA-F]+$/.test(key)).toBe(true)\n\t\t})\n\n\t\tit(\"should generate a 44-character base64 key (32 bytes)\", () => {\n\t\t\tconst key = EncryptionModule.generateEncryptionKey(\"base64\")\n\t\t\texpect(typeof key).toBe(\"string\")\n\t\t\texpect(key.length).toBe(44) // 32 bytes in base64\n\t\t\texpect(/^[a-zA-Z0-9+/=]+$/.test(key)).toBe(true)\n\t\t})\n\n\t\tit(\"should generate a 32-character ascii key (32 bytes)\", () => {\n\t\t\tconst key = EncryptionModule.generateEncryptionKey(\"ascii\")\n\t\t\texpect(typeof key).toBe(\"string\")\n\t\t\texpect(key.length).toBe(32)\n\t\t})\n\n\t\tit(\"should generate a 32-character utf8 key (legacy fallback)\", () => {\n\t\t\tconst key = EncryptionModule.generateEncryptionKey(\"utf8\")\n\t\t\texpect(typeof key).toBe(\"string\")\n\t\t\texpect(key.length).toBe(32) // 16 bytes hex -> 32 chars\n\t\t})\n\n\t\tit(\"should generate different keys on subsequent calls\", () => {\n\t\t\tconst key1 = EncryptionModule.generateEncryptionKey()\n\t\t\tconst key2 = EncryptionModule.generateEncryptionKey()\n\t\t\texpect(key1).not.toBe(key2)\n\t\t})\n\n\t\tit.each([\"hex\", \"base64\", \"ascii\", \"utf8\"] as const)(\n\t\t\t\"should generate a key compatible with aesGcmEncrypt (%s)\",\n\t\t\tasync (encoding) => {\n\t\t\t\tconst key = EncryptionModule.generateEncryptionKey(encoding)\n\t\t\t\tconst data = new Uint8Array(Buffer.from(\"hello world\"))\n\t\t\t\tconst result = await EncryptionModule.aesGcmEncrypt(data, key)\n\t\t\t\texpect(result.ciphertext).toBeDefined()\n\n\t\t\t\tconst decrypted = await EncryptionModule.aesGcmDecrypt(result.ciphertext, result.nonce, key)\n\t\t\t\texpect(decrypted).toEqual(data)\n\t\t\t},\n\t\t)\n\t})\n\n\tdescribe(\"Key Formats\", () => {\n\t\tconst hexKey = \"6fb64e13eb0ad85478f7e792faf6ac8bf46ddd39483e8aed16a82cc5eaaead55\" // 64 chars hex\n\t\tconst base64Key = Buffer.from(hexKey, \"hex\").toString(\"base64\") // 44 chars base64\n\t\tconst utf8Key = \"12345678901234567890123456789012\" // 32 chars utf8\n\n\t\tit(\"should support hex encoded key (64 chars)\", async () => {\n\t\t\tconst result = await EncryptionModule.aesGcmEncrypt(data, hexKey)\n\t\t\texpect(result.ciphertext).toBeDefined()\n\t\t\tconst decrypted = await EncryptionModule.aesGcmDecrypt(result.ciphertext, result.nonce, hexKey)\n\t\t\texpect(decrypted).toEqual(data)\n\t\t})\n\n\t\tit(\"should support base64 encoded key (44 chars)\", async () => {\n\t\t\tconst result = await EncryptionModule.aesGcmEncrypt(data, base64Key)\n\t\t\texpect(result.ciphertext).toBeDefined()\n\t\t\tconst decrypted = await EncryptionModule.aesGcmDecrypt(result.ciphertext, result.nonce, base64Key)\n\t\t\texpect(decrypted).toEqual(data)\n\t\t})\n\n\t\tit(\"should support utf8 key (32 chars)\", async () => {\n\t\t\tconst result = await EncryptionModule.aesGcmEncrypt(data, utf8Key)\n\t\t\texpect(result.ciphertext).toBeDefined()\n\t\t\tconst decrypted = await EncryptionModule.aesGcmDecrypt(result.ciphertext, result.nonce, utf8Key)\n\t\t\texpect(decrypted).toEqual(data)\n\t\t})\n\t})\n})\n"],"mappings":"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","names":["data"]}