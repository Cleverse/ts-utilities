{"version":3,"sources":["../../src/encryption/index.spec.ts"],"sourcesContent":["import crypto from \"node:crypto\"\n\nimport { describe, expect, it } from \"vitest\"\n\nimport { EncryptionModule } from \"./index\"\n\ndescribe(\"EncryptionModule\", () => {\n\tconst validKey = \"12345678901234567890123456789012\" // 32 bytes\n\tconst data = new Uint8Array(Buffer.from(\"hello world\"))\n\n\tdescribe(\"aesGcmEncrypt\", () => {\n\t\tit(\"should encrypt data correctly and return ciphertext and nonce\", async () => {\n\t\t\tconst result = await EncryptionModule.aesGcmEncrypt(data, validKey)\n\n\t\t\texpect(result.ciphertext).toBeDefined()\n\t\t\texpect(typeof result.ciphertext).toBe(\"string\")\n\t\t\texpect(result.nonce).toBeDefined()\n\t\t\texpect(result.nonce).toBeInstanceOf(Uint8Array)\n\t\t\texpect(result.nonce.length).toBe(12)\n\t\t})\n\n\t\tit(\"should use provided nonce if given\", async () => {\n\t\t\tconst nonce = crypto.randomBytes(12)\n\t\t\tconst result = await EncryptionModule.aesGcmEncrypt(data, validKey, nonce)\n\n\t\t\texpect(result.nonce).toEqual(new Uint8Array(nonce))\n\t\t})\n\n\t\tit(\"should throw error if key length is invalid\", async () => {\n\t\t\tawait expect(EncryptionModule.aesGcmEncrypt(data, \"invalid-length\")).rejects.toThrow(\n\t\t\t\t\"Encryption key must be exactly 32 bytes for AES-256\",\n\t\t\t)\n\t\t})\n\t})\n\n\tdescribe(\"aesGcmDecrypt\", () => {\n\t\tit(\"should decrypt data correctly\", async () => {\n\t\t\tconst { ciphertext, nonce } = await EncryptionModule.aesGcmEncrypt(data, validKey)\n\n\t\t\tconst decrypted = await EncryptionModule.aesGcmDecrypt(ciphertext, nonce, validKey)\n\n\t\t\texpect(decrypted).toEqual(data)\n\t\t\texpect(Buffer.from(decrypted).toString()).toBe(\"hello world\")\n\t\t})\n\n\t\tit(\"should throw error if key length is invalid\", async () => {\n\t\t\tconst { ciphertext, nonce } = await EncryptionModule.aesGcmEncrypt(data, validKey)\n\n\t\t\tawait expect(EncryptionModule.aesGcmDecrypt(ciphertext, nonce, \"invalid-length\")).rejects.toThrow(\n\t\t\t\t\"Encryption key must be exactly 32 bytes for AES-256\",\n\t\t\t)\n\t\t})\n\n\t\tit(\"should fail to decrypt with wrong key\", async () => {\n\t\t\tconst { ciphertext, nonce } = await EncryptionModule.aesGcmEncrypt(data, validKey)\n\t\t\tconst wrongKey = \"12345678901234567890123456789013\" // 32 bytes different key\n\n\t\t\tawait expect(EncryptionModule.aesGcmDecrypt(ciphertext, nonce, wrongKey)).rejects.toThrow(\n\t\t\t\t\"Failed to decrypt data\",\n\t\t\t)\n\t\t})\n\t})\n})\n"],"mappings":";;;;;;;;;;;AAAA,OAAO,YAAY;AAMnB,SAAS,oBAAoB,MAAM;AAClC,QAAM,WAAW;AACjB,QAAM,OAAO,IAAI,WAAW,OAAO,KAAK,aAAa,CAAC;AAEtD,WAAS,iBAAiB,MAAM;AAC/B,OAAG,iEAAiE,YAAY;AAC/E,YAAM,SAAS,MAAM,iBAAiB,cAAc,MAAM,QAAQ;AAElE,mBAAO,OAAO,UAAU,EAAE,YAAY;AACtC,mBAAO,OAAO,OAAO,UAAU,EAAE,KAAK,QAAQ;AAC9C,mBAAO,OAAO,KAAK,EAAE,YAAY;AACjC,mBAAO,OAAO,KAAK,EAAE,eAAe,UAAU;AAC9C,mBAAO,OAAO,MAAM,MAAM,EAAE,KAAK,EAAE;AAAA,IACpC,CAAC;AAED,OAAG,sCAAsC,YAAY;AACpD,YAAM,QAAQ,OAAO,YAAY,EAAE;AACnC,YAAM,SAAS,MAAM,iBAAiB,cAAc,MAAM,UAAU,KAAK;AAEzE,mBAAO,OAAO,KAAK,EAAE,QAAQ,IAAI,WAAW,KAAK,CAAC;AAAA,IACnD,CAAC;AAED,OAAG,+CAA+C,YAAY;AAC7D,YAAM,aAAO,iBAAiB,cAAc,MAAM,gBAAgB,CAAC,EAAE,QAAQ;AAAA,QAC5E;AAAA,MACD;AAAA,IACD,CAAC;AAAA,EACF,CAAC;AAED,WAAS,iBAAiB,MAAM;AAC/B,OAAG,iCAAiC,YAAY;AAC/C,YAAM,EAAE,YAAY,MAAM,IAAI,MAAM,iBAAiB,cAAc,MAAM,QAAQ;AAEjF,YAAM,YAAY,MAAM,iBAAiB,cAAc,YAAY,OAAO,QAAQ;AAElF,mBAAO,SAAS,EAAE,QAAQ,IAAI;AAC9B,mBAAO,OAAO,KAAK,SAAS,EAAE,SAAS,CAAC,EAAE,KAAK,aAAa;AAAA,IAC7D,CAAC;AAED,OAAG,+CAA+C,YAAY;AAC7D,YAAM,EAAE,YAAY,MAAM,IAAI,MAAM,iBAAiB,cAAc,MAAM,QAAQ;AAEjF,YAAM,aAAO,iBAAiB,cAAc,YAAY,OAAO,gBAAgB,CAAC,EAAE,QAAQ;AAAA,QACzF;AAAA,MACD;AAAA,IACD,CAAC;AAED,OAAG,yCAAyC,YAAY;AACvD,YAAM,EAAE,YAAY,MAAM,IAAI,MAAM,iBAAiB,cAAc,MAAM,QAAQ;AACjF,YAAM,WAAW;AAEjB,YAAM,aAAO,iBAAiB,cAAc,YAAY,OAAO,QAAQ,CAAC,EAAE,QAAQ;AAAA,QACjF;AAAA,MACD;AAAA,IACD,CAAC;AAAA,EACF,CAAC;AACF,CAAC;","names":[]}