{"version":3,"sources":["/home/runner/work/ts-utilities/ts-utilities/dist/chunk-P6LVEPTD.cjs","../src/utils/aborts/index.ts"],"names":[],"mappings":"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","file":"/home/runner/work/ts-utilities/ts-utilities/dist/chunk-P6LVEPTD.cjs","sourcesContent":[null,"import { addAbortListener } from \"node:events\"\nimport { aborted } from \"node:util\"\n\nimport { delay } from \"../miscellaneous/sleep\"\n\nexport type AbortReason = Error | string | unknown\n\nexport interface RaceResult<T> {\n\tstatus: \"fulfilled\" | \"aborted\"\n\tvalue?: T\n\treason?: AbortReason\n}\n\n/**\n * Returns a promise that resolves when signal is aborted\n * Uses node:util.aborted for memory-safe implementation\n */\nexport async function awaitAbort(signal: AbortSignal, resource?: object): Promise<void> {\n\tif (signal.aborted) {\n\t\treturn Promise.resolve()\n\t}\n\treturn aborted(signal, resource ?? {})\n}\n\n/**\n * Returns a promise that rejects when signal is aborted\n */\nexport async function awaitAbortWithReject(signal: AbortSignal): Promise<never> {\n\tif (signal.aborted) {\n\t\treturn Promise.reject(getAbortReason(signal))\n\t}\n\treturn new Promise((_, reject) => {\n\t\tconst disposable = addAbortListener(signal, () => {\n\t\t\tdisposable[Symbol.dispose]()\n\t\t\treject(getAbortReason(signal))\n\t\t})\n\t})\n}\n\n/**\n * Awaits abort or timeout, returning which occurred first\n */\nexport async function awaitAbortOrTimeout(signal: AbortSignal, timeoutMs: number): Promise<\"aborted\" | \"timeout\"> {\n\treturn Promise.race([\n\t\tawaitAbort(signal).then(() => \"aborted\" as const),\n\t\tdelay(timeoutMs).then(() => \"timeout\" as const),\n\t])\n}\n\n/**\n * Races an async function against AbortSignal\n * Rejects immediately if signal is aborted during execution and returns the abort reason\n */\nexport function withAbortSignal<T>(signal: AbortSignal, asyncFn: () => Promise<T>): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst disposable = addAbortListener(signal, () => {\n\t\t\tdisposable[Symbol.dispose]()\n\t\t\treject(getAbortReason(signal))\n\t\t})\n\n\t\tasyncFn()\n\t\t\t.then(resolve)\n\t\t\t.catch(reject)\n\t\t\t.finally(() => disposable[Symbol.dispose]())\n\t})\n}\n\n/**\n * Races an async function against AbortSignal and returns result status\n * Never throws - returns structured result instead\n */\nexport async function raceWithAbort<T>(signal: AbortSignal, asyncFn: () => Promise<T>): Promise<RaceResult<T>> {\n\ttry {\n\t\tconst value = await withAbortSignal(signal, asyncFn)\n\t\treturn { status: \"fulfilled\", value }\n\t} catch (error) {\n\t\tif (error instanceof DOMException && error.name === \"AbortError\") {\n\t\t\treturn { status: \"aborted\", reason: error }\n\t\t}\n\t\tthrow error // Re-throw non-abort errors\n\t}\n}\n\n/**\n * Races multiple async functions against AbortSignal\n * Returns when first completes or signal aborts\n */\nexport function raceAllWithAbort<T>(signal: AbortSignal, asyncFns: Array<() => Promise<T>>): Promise<T> {\n\treturn withAbortSignal(signal, () => Promise.race(asyncFns.map((fn) => fn())))\n}\n\n/**\n * Creates a standard AbortError with optional reason\n */\nexport function createAbortError(reason?: AbortReason): DOMException {\n\tconst message =\n\t\treason instanceof Error ? reason.message : typeof reason === \"string\" ? reason : \"The operation was aborted\"\n\treturn new DOMException(message, \"AbortError\")\n}\n\n/**\n * Extracts abort reason from signal, creating AbortError if none exists\n */\nexport function getAbortReason(signal: AbortSignal): Error {\n\tif (signal.reason instanceof Error) {\n\t\treturn signal.reason\n\t}\n\treturn createAbortError(signal.reason)\n}\n\nconst Aborts = {\n\tawaitAbort,\n\tawaitAbortWithReject,\n\tawaitAbortOrTimeout,\n\twithAbortSignal,\n\traceWithAbort,\n\traceAllWithAbort,\n\tcreateAbortError,\n\tgetAbortReason,\n}\nexport { Aborts }\nexport default Aborts\n"]}