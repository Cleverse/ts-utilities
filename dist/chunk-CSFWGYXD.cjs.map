{"version":3,"sources":["/home/runner/work/ts-utilities/ts-utilities/dist/chunk-CSFWGYXD.cjs","../src/encryption/index.ts","../src/encryption/encryption.service.ts"],"names":["dek"],"mappings":"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","file":"/home/runner/work/ts-utilities/ts-utilities/dist/chunk-CSFWGYXD.cjs","sourcesContent":[null,"import crypto from \"node:crypto\"\n\nimport VError from \"verror\"\n\nexport * from \"./encryption.service\"\n\n/**\n * Encryption usecase implementing AES-GCM encryption/decryption\n */\nexport class EncryptionModule {\n\t/**\n\t * Encrypts data using AES-GCM algorithm\n\t */\n\tstatic async encrypt(\n\t\tdata: Uint8Array,\n\t\tencryptionKey: string,\n\t\tnonce?: Uint8Array | null,\n\t): Promise<{\n\t\t/** Base64 encoded ciphertext */\n\t\tciphertext: string\n\t\t/** Nonce used for encryption */\n\t\tnonce: Uint8Array\n\t}> {\n\t\ttry {\n\t\t\tif (nonce && nonce.length !== 12) {\n\t\t\t\tthrow new VError(\"Nonce must be exactly 12 bytes\")\n\t\t\t}\n\n\t\t\t// Generate nonce if not provided\n\t\t\tconst actualNonce = nonce ?? crypto.randomBytes(12)\n\n\t\t\t// Validate encryption key length\n\t\t\tconst keyBuffer = EncryptionModule.getKeyBuffer(encryptionKey)\n\t\t\tif (keyBuffer.length !== 32) {\n\t\t\t\tthrow new VError(\"Encryption key must be exactly 32 bytes for AES-256\")\n\t\t\t}\n\n\t\t\t// Create cipher\n\t\t\tconst cipher = crypto.createCipheriv(\"aes-256-gcm\", keyBuffer, actualNonce)\n\n\t\t\t// Encrypt the data\n\t\t\tconst encrypted = Buffer.concat([cipher.update(data), cipher.final()])\n\t\t\tconst authTag = cipher.getAuthTag()\n\n\t\t\t// Combine encrypted data and auth tag\n\t\t\tconst ciphertext = Buffer.concat([encrypted, authTag])\n\n\t\t\t// Convert to base64\n\t\t\tconst base64Ciphertext = ciphertext.toString(\"base64\")\n\n\t\t\treturn {\n\t\t\t\tciphertext: base64Ciphertext,\n\t\t\t\tnonce: new Uint8Array(actualNonce),\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthrow new VError(error as Error, `Failed to encrypt data`)\n\t\t}\n\t}\n\n\t/**\n\t * Decrypts data using AES-GCM algorithm\n\t */\n\tstatic async decrypt(data: string, nonce: Uint8Array, encryptionKey: string): Promise<Uint8Array> {\n\t\ttry {\n\t\t\t// Validate encryption key length\n\t\t\tconst keyBuffer = EncryptionModule.getKeyBuffer(encryptionKey)\n\t\t\tif (keyBuffer.length !== 32) {\n\t\t\t\tthrow new VError(\"Encryption key must be exactly 32 bytes for AES-256\")\n\t\t\t}\n\n\t\t\t// Decode base64 data\n\t\t\tconst decodedData = Buffer.from(data, \"base64\")\n\n\t\t\t// Split ciphertext and auth tag (last 16 bytes)\n\t\t\tconst authTag = decodedData.subarray(-16)\n\t\t\tconst encrypted = decodedData.subarray(0, -16)\n\n\t\t\t// Create decipher\n\t\t\tconst decipher = crypto.createDecipheriv(\"aes-256-gcm\", keyBuffer, Buffer.from(nonce))\n\t\t\tdecipher.setAuthTag(authTag)\n\n\t\t\t// Decrypt the data\n\t\t\tconst plaintext = Buffer.concat([decipher.update(encrypted), decipher.final()])\n\n\t\t\treturn new Uint8Array(plaintext)\n\t\t} catch (error) {\n\t\t\tthrow new VError(error as Error, `Failed to decrypt data`)\n\t\t}\n\t}\n\n\t/**\n\t * Generates a random 32-character encryption key suitable for use with aesGcmEncrypt\n\t */\n\tstatic generateEncryptionKey(encoding: \"hex\" | \"base64\" | \"ascii\" | \"utf8\" = \"hex\"): string {\n\t\t// return crypto.randomBytes(16).toString(\"hex\")\n\t\tswitch (encoding) {\n\t\t\tcase \"utf8\":\n\t\t\t\t// NOTE: UTF8 fails with crypto.randomBytes(32) - non-ASCII bytes (>=128)\n\t\t\t\t// become variable-length multi-byte sequences, yielding unpredictable\n\t\t\t\t// length (e.g., 58 chars instead of 32). Use hex(16 bytes) instead.\n\t\t\t\treturn crypto.randomBytes(16).toString(\"hex\")\n\t\t\tdefault:\n\t\t\t\treturn crypto.randomBytes(32).toString(encoding)\n\t\t}\n\t}\n\n\tprivate static getKeyBuffer(key: string): Buffer {\n\t\t// Hex: 64 chars\n\t\tif (key.length === 64 && /^[0-9a-fA-F]+$/.test(key)) {\n\t\t\treturn Buffer.from(key, \"hex\")\n\t\t}\n\t\t// Base64: 44 chars (32 bytes = 42.6 chars -> 44 with padding)\n\t\tif (key.length === 44 && /^[a-zA-Z0-9+/=]+$/.test(key)) {\n\t\t\treturn Buffer.from(key, \"base64\")\n\t\t}\n\t\t// UTF-8 Fallback\n\t\treturn Buffer.from(key, \"utf8\")\n\t}\n}\n","import { VError } from \"verror\"\n\nimport { EncryptionModule } from \"@/encryption\"\nimport { KMSClient } from \"@/kms\"\nimport { SingleFlight } from \"@/utils/sync\"\n\nexport interface EncryptionConfig {\n\tdefaultVersion?: number // if not provided, will use the latest version from database\n}\n\n/**\n * Shared-DEK Envelope Encryption service for PII and sensitive Data\n */\nexport class EnvelopeEncryptionService {\n\t// NOTE: Always use `#` instead of `private` keyword for serious private properties to avoid by-passing the access control\n\treadonly #deks = new Map<number, DEK>()\n\n\tconstructor(\n\t\tprivate readonly kmsClient: KMSClient,\n\t\tprivate readonly sharedDEKDatagateway: SharedDEKDatagateway,\n\t\tprivate readonly config: EncryptionConfig,\n\t) {}\n\n\t/**\n\t * Encrypt the data using the DEK\n\t */\n\tasync encrypt(\n\t\tdata: Uint8Array,\n\t\tnonce?: Uint8Array | null,\n\t\tdekVersion?: number,\n\t): Promise<{\n\t\tdekVersion: number\n\t\tnonce: Uint8Array\n\t\tciphertext: string\n\t}> {\n\t\tconst dek = await this.#getDEK(dekVersion)\n\t\tif (!dek) {\n\t\t\tthrow new VError(`Failed to encrypt data, DEK not found`)\n\t\t}\n\t\tconst encrypted = await EncryptionModule.encrypt(data, dek.dek, nonce)\n\t\treturn {\n\t\t\tdekVersion: dek.version,\n\t\t\tnonce: encrypted.nonce,\n\t\t\tciphertext: encrypted.ciphertext,\n\t\t}\n\t}\n\n\t/**\n\t * Decrypt the data using the DEK\n\t */\n\tasync decrypt(ciphertext: string, nonce: Uint8Array, dekVersion: number): Promise<Uint8Array> {\n\t\tconst dek = await this.#getDEK(dekVersion)\n\t\tif (!dek) {\n\t\t\tthrow new VError(`Failed to decrypt data, DEK not found`)\n\t\t}\n\t\treturn EncryptionModule.decrypt(ciphertext, nonce, dek.dek)\n\t}\n\n\t/**\n\t * Rotates the DEK by encrypting a new DEK with the KMS client and inserting it into the database\n\t *\n\t * @param kekVersion The version of the KMS key to use for encryption. Required for asymmetric encryption.\n\t */\n\tasync rotateDEK(kekVersion?: string): Promise<number> {\n\t\tconst dek = EncryptionModule.generateEncryptionKey(\"hex\")\n\t\tconst { ciphertext, cryptoKeyVersion } = await this.kmsClient.encrypt(dek, kekVersion)\n\t\tconst { version } = await this.sharedDEKDatagateway.insertNewDEK(ciphertext, parseInt(cryptoKeyVersion, 10))\n\t\treturn version\n\t}\n\n\tasync #getDEK(version?: number): Promise<DEK | null> {\n\t\tconst dekVersion = version ?? this.config.defaultVersion\n\t\treturn SingleFlight.withLock(`ts-utilities:encryption:getdek:${dekVersion ?? \"latest\"}`, async () => {\n\t\t\tif (dekVersion) {\n\t\t\t\tconst dek = this.#deks.get(dekVersion)\n\t\t\t\tif (dek) {\n\t\t\t\t\treturn dek\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst encryptedDek = await this.sharedDEKDatagateway.getDEK(dekVersion)\n\t\t\tif (!encryptedDek) {\n\t\t\t\treturn null\n\t\t\t}\n\n\t\t\tconst dek = await this.kmsClient.decrypt(encryptedDek.encryptedDek, encryptedDek.kekVersion.toString())\n\t\t\tconst decryptedDek = {\n\t\t\t\tversion: encryptedDek.version,\n\t\t\t\tdek,\n\t\t\t\tkekVersion: encryptedDek.kekVersion,\n\t\t\t}\n\n\t\t\t// Caching DEKs\n\t\t\tthis.#deks.set(decryptedDek.version, decryptedDek)\n\n\t\t\treturn decryptedDek\n\t\t})\n\t}\n}\n\n/**\n * DEK with version and KMS key version (Decrypted DEK)\n */\nexport type DEK = {\n\tversion: number\n\tdek: string\n\tkekVersion: number\n}\n\n/**\n * Encrypted DEK with KMS key version\n */\nexport interface EncryptedDEK {\n\tversion: number\n\tencryptedDek: string\n\tkekVersion: number\n}\n\n/**\n * Datagateway for Shared DEKs\n */\nexport interface SharedDEKDatagateway {\n\tgetDEK(version?: number): Promise<EncryptedDEK | null>\n\tinsertNewDEK(encryptedDek: string, kekVersion: number): Promise<EncryptedDEK>\n}\n"]}