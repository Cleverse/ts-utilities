{"version":3,"sources":["../src/encryption/index.ts"],"sourcesContent":["import crypto from \"node:crypto\"\n\nimport VError from \"verror\"\n\n/**\n * Encryption usecase implementing AES-GCM encryption/decryption\n */\nexport class EncryptionModule {\n\t/**\n\t * Encrypts data using AES-GCM algorithm\n\t */\n\tstatic async aesGcmEncrypt(\n\t\tdata: Uint8Array,\n\t\tencryptionKey: string,\n\t\tnonce?: Uint8Array | null,\n\t): Promise<{\n\t\t/** Base64 encoded ciphertext */\n\t\tciphertext: string\n\t\t/** Nonce used for encryption */\n\t\tnonce: Uint8Array\n\t}> {\n\t\ttry {\n\t\t\t// Generate nonce if not provided\n\t\t\tconst actualNonce = nonce ?? crypto.randomBytes(12)\n\n\t\t\t// Validate encryption key length\n\t\t\tconst keyBuffer = Buffer.from(encryptionKey, \"utf8\")\n\t\t\tif (keyBuffer.length !== 32) {\n\t\t\t\tthrow new VError(\"Encryption key must be exactly 32 bytes for AES-256\")\n\t\t\t}\n\n\t\t\t// Create cipher\n\t\t\tconst cipher = crypto.createCipheriv(\"aes-256-gcm\", keyBuffer, actualNonce)\n\n\t\t\t// Encrypt the data\n\t\t\tconst encrypted = Buffer.concat([cipher.update(data), cipher.final()])\n\t\t\tconst authTag = cipher.getAuthTag()\n\n\t\t\t// Combine encrypted data and auth tag\n\t\t\tconst ciphertext = Buffer.concat([encrypted, authTag])\n\n\t\t\t// Convert to base64\n\t\t\tconst base64Ciphertext = ciphertext.toString(\"base64\")\n\n\t\t\treturn {\n\t\t\t\tciphertext: base64Ciphertext,\n\t\t\t\tnonce: new Uint8Array(actualNonce),\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthrow new VError(error as Error, `Failed to encrypt data`)\n\t\t}\n\t}\n\n\t/**\n\t * Decrypts data using AES-GCM algorithm\n\t */\n\tstatic async aesGcmDecrypt(data: string, nonce: Uint8Array, encryptionKey: string): Promise<Uint8Array> {\n\t\ttry {\n\t\t\t// Validate encryption key length\n\t\t\tconst keyBuffer = Buffer.from(encryptionKey, \"utf8\")\n\t\t\tif (keyBuffer.length !== 32) {\n\t\t\t\tthrow new VError(\"Encryption key must be exactly 32 bytes for AES-256\")\n\t\t\t}\n\n\t\t\t// Decode base64 data\n\t\t\tconst decodedData = Buffer.from(data, \"base64\")\n\n\t\t\t// Split ciphertext and auth tag (last 16 bytes)\n\t\t\tconst authTag = decodedData.subarray(-16)\n\t\t\tconst encrypted = decodedData.subarray(0, -16)\n\n\t\t\t// Create decipher\n\t\t\tconst decipher = crypto.createDecipheriv(\"aes-256-gcm\", keyBuffer, Buffer.from(nonce))\n\t\t\tdecipher.setAuthTag(authTag)\n\n\t\t\t// Decrypt the data\n\t\t\tconst plaintext = Buffer.concat([decipher.update(encrypted), decipher.final()])\n\n\t\t\treturn new Uint8Array(plaintext)\n\t\t} catch (error) {\n\t\t\tthrow new VError(error as Error, `Failed to decrypt data`)\n\t\t}\n\t}\n}\n"],"mappings":";AAAA,OAAO,YAAY;AAEnB,OAAO,YAAY;AAKZ,IAAM,mBAAN,MAAuB;AAAA;AAAA;AAAA;AAAA,EAI7B,aAAa,cACZ,MACA,eACA,OAME;AACF,QAAI;AAEH,YAAM,cAAc,SAAS,OAAO,YAAY,EAAE;AAGlD,YAAM,YAAY,OAAO,KAAK,eAAe,MAAM;AACnD,UAAI,UAAU,WAAW,IAAI;AAC5B,cAAM,IAAI,OAAO,qDAAqD;AAAA,MACvE;AAGA,YAAM,SAAS,OAAO,eAAe,eAAe,WAAW,WAAW;AAG1E,YAAM,YAAY,OAAO,OAAO,CAAC,OAAO,OAAO,IAAI,GAAG,OAAO,MAAM,CAAC,CAAC;AACrE,YAAM,UAAU,OAAO,WAAW;AAGlC,YAAM,aAAa,OAAO,OAAO,CAAC,WAAW,OAAO,CAAC;AAGrD,YAAM,mBAAmB,WAAW,SAAS,QAAQ;AAErD,aAAO;AAAA,QACN,YAAY;AAAA,QACZ,OAAO,IAAI,WAAW,WAAW;AAAA,MAClC;AAAA,IACD,SAAS,OAAO;AACf,YAAM,IAAI,OAAO,OAAgB,wBAAwB;AAAA,IAC1D;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,aAAa,cAAc,MAAc,OAAmB,eAA4C;AACvG,QAAI;AAEH,YAAM,YAAY,OAAO,KAAK,eAAe,MAAM;AACnD,UAAI,UAAU,WAAW,IAAI;AAC5B,cAAM,IAAI,OAAO,qDAAqD;AAAA,MACvE;AAGA,YAAM,cAAc,OAAO,KAAK,MAAM,QAAQ;AAG9C,YAAM,UAAU,YAAY,SAAS,GAAG;AACxC,YAAM,YAAY,YAAY,SAAS,GAAG,GAAG;AAG7C,YAAM,WAAW,OAAO,iBAAiB,eAAe,WAAW,OAAO,KAAK,KAAK,CAAC;AACrF,eAAS,WAAW,OAAO;AAG3B,YAAM,YAAY,OAAO,OAAO,CAAC,SAAS,OAAO,SAAS,GAAG,SAAS,MAAM,CAAC,CAAC;AAE9E,aAAO,IAAI,WAAW,SAAS;AAAA,IAChC,SAAS,OAAO;AACf,YAAM,IAAI,OAAO,OAAgB,wBAAwB;AAAA,IAC1D;AAAA,EACD;AACD;","names":[]}