{"version":3,"sources":["/home/runner/work/ts-utilities/ts-utilities/dist/chunk-4YCXTTUU.cjs","../src/utils/sync/singleFlight.ts"],"names":[],"mappings":"AAAA;AACE;AACF,wDAA6B;AAC7B;AACA;ACJA,8CAAA,CAAA;AAKO,IAAM,aAAA,YAAN,MAAM,cAAa;AAAA,EACzB,4BAAe,MAAA,kBAAQ,IAAI,GAAA,CAA8B,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUzD,OAAA,MAAa,QAAA,CAAY,GAAA,EAAa,EAAA,EAAkC;AAEvE,IAAA,GAAA,CAAI,aAAA,CAAa,KAAA,CAAM,GAAA,CAAI,GAAG,CAAA,EAAG;AAChC,MAAA,OAAO,aAAA,CAAa,KAAA,CAAM,GAAA,CAAI,GAAG,CAAA;AAAA,IAClC;AAEA,IAAA,IAAI;AAEH,MAAA,MAAM,QAAA,EAAU,EAAA,CAAG,CAAA;AACnB,MAAA,aAAA,CAAa,KAAA,CAAM,GAAA,CAAI,GAAA,EAAK,OAAO,CAAA;AACnC,MAAA,OAAO,MAAM,OAAA;AAAA,IACd,EAAA,QAAE;AACD,MAAA,aAAA,CAAa,KAAA,CAAM,MAAA,CAAO,GAAG,CAAA;AAAA,IAC9B;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,aAAA,CAAA,EAAsB;AAC5B,IAAA,aAAA,CAAa,KAAA,CAAM,KAAA,CAAM,CAAA;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,OAAO,OAAA,CAAQ,GAAA,EAAsB;AACpC,IAAA,OAAO,aAAA,CAAa,KAAA,CAAM,GAAA,CAAI,GAAG,CAAA;AAAA,EAClC;AACD,iCAAA;ADJA;AACA;AACE;AACF,oCAAC","file":"/home/runner/work/ts-utilities/ts-utilities/dist/chunk-4YCXTTUU.cjs","sourcesContent":[null,"/**\n * A cache for in-flight requests to prevent duplicate network calls (singleflight pattern)\n * When multiple identical requests are made concurrently, only the first one will be executed\n * and all others will receive the result from the first request.\n */\nexport class SingleFlight {\n\tprivate static locks = new Map<string, Promise<unknown>>()\n\n\t/**\n\t * Executes the provided function with a lock based on the given key.\n\t * If a request with the same key is already in progress, it returns the promise from that request.\n\t *\n\t * @param key - Unique identifier for the request\n\t * @param fn - Function to execute if no lock exists\n\t * @returns Promise with the result of the function execution\n\t */\n\tstatic async withLock<T>(key: string, fn: () => Promise<T>): Promise<T> {\n\t\t// If there's already a request in flight with this key, return its promise\n\t\tif (SingleFlight.locks.has(key)) {\n\t\t\treturn SingleFlight.locks.get(key) as Promise<T>\n\t\t}\n\n\t\ttry {\n\t\t\t// Store the promise in the locks object\n\t\t\tconst promise = fn()\n\t\t\tSingleFlight.locks.set(key, promise)\n\t\t\treturn await promise\n\t\t} finally {\n\t\t\tSingleFlight.locks.delete(key)\n\t\t}\n\t}\n\n\t/**\n\t * Removes all locks - useful for testing or forced resets\n\t */\n\tstatic clearAllLocks(): void {\n\t\tSingleFlight.locks.clear()\n\t}\n\n\t/**\n\t * Checks if a lock exists for the given key\n\t *\n\t * @param key - Unique identifier for the request\n\t * @returns boolean indicating if a lock exists\n\t */\n\tstatic hasLock(key: string): boolean {\n\t\treturn SingleFlight.locks.has(key)\n\t}\n}\n"]}