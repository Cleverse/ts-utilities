{"version":3,"sources":["/home/runner/work/ts-utilities/ts-utilities/dist/chunk-EYW4TGSO.cjs","../src/utils/miscellaneous/jsonl.ts"],"names":[],"mappings":"AAAA;AACE;AACF,wDAA6B;AAC7B;AACA;ACJA,8CAAA,CAAA;AACA,gCAAuB;AAKvB,MAAA,SAAsB,iBAAA,CAA2B,MAAA,EAAkD;AAElG,EAAA,OAAO,KAAA,CAAM,SAAA,CAAU,sBAAA,CAAuB,MAAM,CAAC,CAAA;AACtD;AAKA,MAAA,QAAA,EAAuB,sBAAA,CACtB,MAAA,EACA,OAAA,EAG2B;AAC3B,EAAA,MAAM,OAAA,EAAS,MAAA,CAAO,WAAA,CAAY,IAAI,iBAAA,CAAkB,CAAC,CAAA;AACzD,EAAA,IAAI,OAAA,EAAS,EAAA;AACb,EAAA,IAAI,YAAA,EAAc,CAAA;AAClB,EAAA,IAAA,MAAA,CAAA,MAAiB,MAAA,GAAS,MAAA,EAAQ;AACjC,IAAA,OAAA,GAAU,KAAA;AACV,IAAA,MAAM,MAAA,EAAQ,MAAA,CAAO,KAAA,CAAM,IAAI,CAAA;AAC/B,IAAA,OAAA,mBAAS,KAAA,CAAM,GAAA,CAAI,CAAA,UAAK,IAAA;AAExB,IAAA,IAAA,CAAA,MAAW,KAAA,GAAQ,KAAA,EAAO;AACzB,MAAA,GAAA,CAAI,IAAA,CAAK,IAAA,CAAK,EAAA,IAAM,EAAA,EAAI,QAAA;AAExB,MAAA,IAAI;AACH,QAAA,MAAM,OAAA,EAAS,IAAA,CAAK,KAAA,CAAM,IAAI,CAAA;AAC9B,QAAA,MAAM,MAAA;AAAA,MACP,EAAA,MAAA,CAAS,KAAA,EAAO;AACf,QAAA,GAAA,iBAAI,OAAA,2BAAS,iBAAA,EAAiB,QAAA;AAC9B,QAAA,MAAM,IAAI,mBAAA,CAAO,KAAA,EAAgB,CAAA,2BAAA,EAA8B,WAAW,CAAA,CAAA,CAAG,CAAA;AAAA,MAC9E,EAAA,QAAE;AACD,QAAA,WAAA,EAAA;AAAA,MACD;AAAA,IACD;AAAA,EACD;AACA,EAAA,GAAA,CAAI,MAAA,CAAO,IAAA,CAAK,EAAA,IAAM,EAAA,EAAI;AACzB,IAAA,IAAI;AACH,MAAA,MAAM,OAAA,EAAS,IAAA,CAAK,KAAA,CAAM,MAAM,CAAA;AAChC,MAAA,MAAM,MAAA;AAAA,IACP,EAAA,MAAA,CAAS,KAAA,EAAO;AACf,MAAA,GAAA,iBAAI,OAAA,6BAAS,iBAAA,EAAiB,MAAA;AAC9B,MAAA,MAAM,IAAI,mBAAA,CAAO,KAAA,EAAgB,CAAA,iCAAA,EAAoC,WAAW,CAAA,CAAA,CAAG,CAAA;AAAA,IACpF;AAAA,EACD;AACD;ADVA;AACA;AACE;AACA;AACF,uGAAC","file":"/home/runner/work/ts-utilities/ts-utilities/dist/chunk-EYW4TGSO.cjs","sourcesContent":[null,"/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { VError } from \"verror\"\n\n/**\n * Decode a jsonl stream into an array of objects.\n */\nexport async function jsonlDecodeStream<T = any>(stream: ReadableStream<Uint8Array>): Promise<T[]> {\n\t// or use `await new Response(stream).text()` and jsonl.parse(string) instead.\n\treturn Array.fromAsync(jsonlDecodeStreamAsync(stream))\n}\n\n/**\n * Asynchronously decode a jsonl stream into an array of objects.\n */\nexport async function* jsonlDecodeStreamAsync<T = any>(\n\tstream: ReadableStream,\n\toptions?: {\n\t\tskipInvalidLine?: boolean\n\t},\n): AsyncIterableIterator<T> {\n\tconst reader = stream.pipeThrough(new TextDecoderStream())\n\tlet memory = \"\"\n\tlet currentLine = 0\n\tfor await (const chunk of reader) {\n\t\tmemory += chunk\n\t\tconst lines = memory.split(\"\\n\")\n\t\tmemory = lines.pop() ?? \"\" // Keep the last line (might be incomplete)\n\n\t\tfor (const line of lines) {\n\t\t\tif (line.trim() === \"\") continue\n\n\t\t\ttry {\n\t\t\t\tconst parsed = JSON.parse(line) as T\n\t\t\t\tyield parsed\n\t\t\t} catch (error) {\n\t\t\t\tif (options?.skipInvalidLine) continue\n\t\t\t\tthrow new VError(error as Error, `Failed to parse JSONL line[${currentLine}]`)\n\t\t\t} finally {\n\t\t\t\tcurrentLine++\n\t\t\t}\n\t\t}\n\t}\n\tif (memory.trim() !== \"\") {\n\t\ttry {\n\t\t\tconst parsed = JSON.parse(memory) as T\n\t\t\tyield parsed\n\t\t} catch (error) {\n\t\t\tif (options?.skipInvalidLine) return\n\t\t\tthrow new VError(error as Error, `Failed to parse final JSONL line[${currentLine}]`)\n\t\t}\n\t}\n}\n"]}