{"version":3,"sources":["/home/runner/work/ts-utilities/ts-utilities/dist/chunk-IMEGYM73.cjs","../src/encryption/index.ts"],"names":[],"mappings":"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","file":"/home/runner/work/ts-utilities/ts-utilities/dist/chunk-IMEGYM73.cjs","sourcesContent":[null,"import crypto from \"node:crypto\"\n\nimport VError from \"verror\"\n\n/**\n * Encryption usecase implementing AES-GCM encryption/decryption\n */\nexport class EncryptionModule {\n\t/**\n\t * Encrypts data using AES-GCM algorithm\n\t */\n\tstatic async aesGcmEncrypt(\n\t\tdata: Uint8Array,\n\t\tencryptionKey: string,\n\t\tnonce?: Uint8Array | null,\n\t): Promise<{\n\t\t/** Base64 encoded ciphertext */\n\t\tciphertext: string\n\t\t/** Nonce used for encryption */\n\t\tnonce: Uint8Array\n\t}> {\n\t\ttry {\n\t\t\t// Generate nonce if not provided\n\t\t\tconst actualNonce = nonce ?? crypto.randomBytes(12)\n\n\t\t\t// Validate encryption key length\n\t\t\tconst keyBuffer = EncryptionModule.getKeyBuffer(encryptionKey)\n\t\t\tif (keyBuffer.length !== 32) {\n\t\t\t\tthrow new VError(\"Encryption key must be exactly 32 bytes for AES-256\")\n\t\t\t}\n\n\t\t\t// Create cipher\n\t\t\tconst cipher = crypto.createCipheriv(\"aes-256-gcm\", keyBuffer, actualNonce)\n\n\t\t\t// Encrypt the data\n\t\t\tconst encrypted = Buffer.concat([cipher.update(data), cipher.final()])\n\t\t\tconst authTag = cipher.getAuthTag()\n\n\t\t\t// Combine encrypted data and auth tag\n\t\t\tconst ciphertext = Buffer.concat([encrypted, authTag])\n\n\t\t\t// Convert to base64\n\t\t\tconst base64Ciphertext = ciphertext.toString(\"base64\")\n\n\t\t\treturn {\n\t\t\t\tciphertext: base64Ciphertext,\n\t\t\t\tnonce: new Uint8Array(actualNonce),\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthrow new VError(error as Error, `Failed to encrypt data`)\n\t\t}\n\t}\n\n\t/**\n\t * Decrypts data using AES-GCM algorithm\n\t */\n\tstatic async aesGcmDecrypt(data: string, nonce: Uint8Array, encryptionKey: string): Promise<Uint8Array> {\n\t\ttry {\n\t\t\t// Validate encryption key length\n\t\t\tconst keyBuffer = EncryptionModule.getKeyBuffer(encryptionKey)\n\t\t\tif (keyBuffer.length !== 32) {\n\t\t\t\tthrow new VError(\"Encryption key must be exactly 32 bytes for AES-256\")\n\t\t\t}\n\n\t\t\t// Decode base64 data\n\t\t\tconst decodedData = Buffer.from(data, \"base64\")\n\n\t\t\t// Split ciphertext and auth tag (last 16 bytes)\n\t\t\tconst authTag = decodedData.subarray(-16)\n\t\t\tconst encrypted = decodedData.subarray(0, -16)\n\n\t\t\t// Create decipher\n\t\t\tconst decipher = crypto.createDecipheriv(\"aes-256-gcm\", keyBuffer, Buffer.from(nonce))\n\t\t\tdecipher.setAuthTag(authTag)\n\n\t\t\t// Decrypt the data\n\t\t\tconst plaintext = Buffer.concat([decipher.update(encrypted), decipher.final()])\n\n\t\t\treturn new Uint8Array(plaintext)\n\t\t} catch (error) {\n\t\t\tthrow new VError(error as Error, `Failed to decrypt data`)\n\t\t}\n\t}\n\n\t/**\n\t * Generates a random 32-character encryption key suitable for use with aesGcmEncrypt\n\t */\n\tstatic generateEncryptionKey(encoding: \"hex\" | \"base64\" | \"ascii\" | \"utf8\" = \"hex\"): string {\n\t\t// return crypto.randomBytes(16).toString(\"hex\")\n\t\tswitch (encoding) {\n\t\t\tcase \"utf8\":\n\t\t\t\t// NOTE: UTF8 fails with crypto.randomBytes(32) - non-ASCII bytes (>=128)\n\t\t\t\t// become variable-length multi-byte sequences, yielding unpredictable\n\t\t\t\t// length (e.g., 58 chars instead of 32). Use hex(16 bytes) instead.\n\t\t\t\treturn crypto.randomBytes(16).toString(\"hex\")\n\t\t\tdefault:\n\t\t\t\treturn crypto.randomBytes(32).toString(encoding)\n\t\t}\n\t}\n\n\tprivate static getKeyBuffer(key: string): Buffer {\n\t\t// Hex: 64 chars\n\t\tif (key.length === 64 && /^[0-9a-fA-F]+$/.test(key)) {\n\t\t\treturn Buffer.from(key, \"hex\")\n\t\t}\n\t\t// Base64: 44 chars (32 bytes = 42.6 chars -> 44 with padding)\n\t\tif (key.length === 44 && /^[a-zA-Z0-9+/=]+$/.test(key)) {\n\t\t\treturn Buffer.from(key, \"base64\")\n\t\t}\n\t\t// UTF-8 Fallback\n\t\treturn Buffer.from(key, \"utf8\")\n\t}\n}\n"]}