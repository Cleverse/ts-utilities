{"version":3,"sources":["/home/runner/work/ts-utilities/ts-utilities/dist/magic-string.es-2Q5FG7E2.cjs","../node_modules/.pnpm/@jridgewell+sourcemap-codec@1.5.5/node_modules/@jridgewell/sourcemap-codec/src/vlq.ts","../node_modules/.pnpm/@jridgewell+sourcemap-codec@1.5.5/node_modules/@jridgewell/sourcemap-codec/src/strings.ts","../node_modules/.pnpm/@jridgewell+sourcemap-codec@1.5.5/node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts","../node_modules/.pnpm/magic-string@0.30.21/node_modules/magic-string/src/BitSet.js","../node_modules/.pnpm/magic-string@0.30.21/node_modules/magic-string/src/Chunk.js","../node_modules/.pnpm/magic-string@0.30.21/node_modules/magic-string/src/SourceMap.js","../node_modules/.pnpm/magic-string@0.30.21/node_modules/magic-string/src/utils/guessIndent.js","../node_modules/.pnpm/magic-string@0.30.21/node_modules/magic-string/src/utils/getRelativePath.js","../node_modules/.pnpm/magic-string@0.30.21/node_modules/magic-string/src/utils/isObject.js","../node_modules/.pnpm/magic-string@0.30.21/node_modules/magic-string/src/utils/getLocator.js","../node_modules/.pnpm/magic-string@0.30.21/node_modules/magic-string/src/utils/Mappings.js","../node_modules/.pnpm/magic-string@0.30.21/node_modules/magic-string/src/MagicString.js","../node_modules/.pnpm/magic-string@0.30.21/node_modules/magic-string/src/Bundle.js"],"names":["n","segment"],"mappings":"AAAA;AACE;AACF,wDAA6B;AAC7B;AACA;AACA,8CAAc,CAAE;AAChB;AACA;AACA,8CAAc,CAAE;ACNT,IAAM,MAAA,EAAQ,GAAA,CAAI,UAAA,CAAW,CAAC,CAAA;AAC9B,IAAM,UAAA,EAAY,GAAA,CAAI,UAAA,CAAW,CAAC,CAAA;AAEzC,IAAM,MAAA,EAAQ,kEAAA;AACd,IAAM,UAAA,EAAY,IAAI,UAAA,CAAW,EAAE,CAAA;AACnC,IAAM,UAAA,EAAY,IAAI,UAAA,CAAW,GAAG,CAAA;AAEpC,IAAA,CAAA,IAAS,EAAA,EAAI,CAAA,EAAG,EAAA,EAAI,KAAA,CAAM,MAAA,EAAQ,CAAA,EAAA,EAAK;AACrC,EAAA,MAAM,EAAA,EAAI,KAAA,CAAM,UAAA,CAAW,CAAC,CAAA;AAC5B,EAAA,SAAA,CAAU,CAAC,EAAA,EAAI,CAAA;AACf,EAAA,SAAA,CAAU,CAAC,EAAA,EAAI,CAAA;AACjB;AAwBO,SAAS,aAAA,CAAc,OAAA,EAAuB,GAAA,EAAa,QAAA,EAA0B;AAC1F,EAAA,IAAI,MAAA,EAAQ,IAAA,EAAM,QAAA;AAElB,EAAA,MAAA,EAAQ,MAAA,EAAQ,EAAA,EAAK,CAAC,MAAA,GAAS,EAAA,EAAK,EAAA,EAAI,MAAA,GAAS,CAAA;AACjD,EAAA,GAAG;AACD,IAAA,IAAI,QAAA,EAAU,MAAA,EAAQ,EAAA;AACtB,IAAA,MAAA,KAAW,CAAA;AACX,IAAA,GAAA,CAAI,MAAA,EAAQ,CAAA,EAAG,QAAA,GAAW,EAAA;AAC1B,IAAA,OAAA,CAAQ,KAAA,CAAM,SAAA,CAAU,OAAO,CAAC,CAAA;ADlBpC,ECmBE,EAAA,MAAA,CAAS,MAAA,EAAQ,CAAA,CAAA;AAEjB,EAAA,OAAO,GAAA;AACT;ACjDA,IAAM,UAAA,EAAY,KAAA,EAAO,EAAA;AAGzB,IAAM,GAAA,EACJ,OAAO,YAAA,IAAgB,YAAA,kBACH,IAAI,WAAA,CAAY,EAAA,EAChC,OAAO,OAAA,IAAW,YAAA,EAChB;AFyBR,EExBU,MAAA,CAAO,GAAA,EAAyB;AAC9B,IAAA,MAAM,IAAA,EAAM,MAAA,CAAO,IAAA,CAAK,GAAA,CAAI,MAAA,EAAQ,GAAA,CAAI,UAAA,EAAY,GAAA,CAAI,UAAU,CAAA;AAClE,IAAA,OAAO,GAAA,CAAI,QAAA,CAAS,CAAA;AFyBhC,EExBU;AACF,EAAA,EACA;AFwBR,EEvBU,MAAA,CAAO,GAAA,EAAyB;AAC9B,IAAA,IAAI,IAAA,EAAM,EAAA;AACV,IAAA,IAAA,CAAA,IAAS,EAAA,EAAI,CAAA,EAAG,EAAA,EAAI,GAAA,CAAI,MAAA,EAAQ,CAAA,EAAA,EAAK;AACnC,MAAA,IAAA,GAAO,MAAA,CAAO,YAAA,CAAa,GAAA,CAAI,CAAC,CAAC,CAAA;AFwB/C,IEvBY;AACA,IAAA,OAAO,GAAA;AFwBnB,EEvBU;AACF,CAAA;AAED,IAAM,aAAA,EAAN,MAAmB;AFuB1B,EEvBO,WAAA,CAAA,EAAA;AACL,IAAA,IAAA,CAAA,IAAA,EAAM,CAAA;AACN,IAAA,IAAA,CAAQ,IAAA,EAAM,EAAA;AACd,IAAA,IAAA,CAAQ,OAAA,EAAS,IAAI,UAAA,CAAW,SAAS,CAAA;AFwB3C,EExB2C;AFyB3C,EEvBE,KAAA,CAAM,CAAA,EAAiB;AACrB,IAAA,MAAM,EAAE,OAAO,EAAA,EAAI,IAAA;AACnB,IAAA,MAAA,CAAO,IAAA,CAAK,GAAA,EAAK,EAAA,EAAI,CAAA;AACrB,IAAA,GAAA,CAAI,IAAA,CAAK,IAAA,IAAQ,SAAA,EAAW;AAC1B,MAAA,IAAA,CAAK,IAAA,GAAO,EAAA,CAAG,MAAA,CAAO,MAAM,CAAA;AAC5B,MAAA,IAAA,CAAK,IAAA,EAAM,CAAA;AFwBjB,IEvBI;AFwBJ,EEvBE;AFwBF,EEtBE,KAAA,CAAA,EAAgB;AACd,IAAA,MAAM,EAAE,MAAA,EAAQ,GAAA,EAAK,IAAI,EAAA,EAAI,IAAA;AAC7B,IAAA,OAAO,IAAA,EAAM,EAAA,EAAI,IAAA,EAAM,EAAA,CAAG,MAAA,CAAO,MAAA,CAAO,QAAA,CAAS,CAAA,EAAG,GAAG,CAAC,EAAA,EAAI,GAAA;AFuBhE,EEtBE;AACF,CAAA;ACsCO,SAAS,MAAA,CAAO,OAAA,EAA8C;AACnE,EAAA,MAAM,OAAA,EAAS,IAAI,YAAA,CAAa,CAAA;AAChC,EAAA,IAAI,aAAA,EAAe,CAAA;AACnB,EAAA,IAAI,WAAA,EAAa,CAAA;AACjB,EAAA,IAAI,aAAA,EAAe,CAAA;AACnB,EAAA,IAAI,WAAA,EAAa,CAAA;AAEjB,EAAA,IAAA,CAAA,IAAS,EAAA,EAAI,CAAA,EAAG,EAAA,EAAI,OAAA,CAAQ,MAAA,EAAQ,CAAA,EAAA,EAAK;AACvC,IAAA,MAAM,KAAA,EAAO,OAAA,CAAQ,CAAC,CAAA;AACtB,IAAA,GAAA,CAAI,EAAA,EAAI,CAAA,EAAG,MAAA,CAAO,KAAA,CAAM,SAAS,CAAA;AACjC,IAAA,GAAA,CAAI,IAAA,CAAK,OAAA,IAAW,CAAA,EAAG,QAAA;AAEvB,IAAA,IAAI,UAAA,EAAY,CAAA;AAEhB,IAAA,IAAA,CAAA,IAAS,EAAA,EAAI,CAAA,EAAG,EAAA,EAAI,IAAA,CAAK,MAAA,EAAQ,CAAA,EAAA,EAAK;AACpC,MAAA,MAAM,QAAA,EAAU,IAAA,CAAK,CAAC,CAAA;AACtB,MAAA,GAAA,CAAI,EAAA,EAAI,CAAA,EAAG,MAAA,CAAO,KAAA,CAAM,KAAK,CAAA;AAE7B,MAAA,UAAA,EAAY,aAAA,CAAc,MAAA,EAAQ,OAAA,CAAQ,CAAC,CAAA,EAAG,SAAS,CAAA;AAEvD,MAAA,GAAA,CAAI,OAAA,CAAQ,OAAA,IAAW,CAAA,EAAG,QAAA;AAC1B,MAAA,aAAA,EAAe,aAAA,CAAc,MAAA,EAAQ,OAAA,CAAQ,CAAC,CAAA,EAAG,YAAY,CAAA;AAC7D,MAAA,WAAA,EAAa,aAAA,CAAc,MAAA,EAAQ,OAAA,CAAQ,CAAC,CAAA,EAAG,UAAU,CAAA;AACzD,MAAA,aAAA,EAAe,aAAA,CAAc,MAAA,EAAQ,OAAA,CAAQ,CAAC,CAAA,EAAG,YAAY,CAAA;AAE7D,MAAA,GAAA,CAAI,OAAA,CAAQ,OAAA,IAAW,CAAA,EAAG,QAAA;AAC1B,MAAA,WAAA,EAAa,aAAA,CAAc,MAAA,EAAQ,OAAA,CAAQ,CAAC,CAAA,EAAG,UAAU,CAAA;AHpB/D,IGqBI;AHpBJ,EGqBE;AAEA,EAAA,OAAO,MAAA,CAAO,KAAA,CAAM,CAAA;AACtB;AHrBA;AACA;AI1Fe,IAAM,OAAA,EAAN,MAAM,QAAO;AJ4F5B,EI3FC,WAAA,CAAY,GAAA,EAAK;AAChB,IAAA,IAAA,CAAK,KAAA,EAAO,IAAA,WAAe,QAAA,EAAS,GAAA,CAAI,IAAA,CAAK,KAAA,CAAK,EAAA,EAAK,CAAA,CAAA;AJ4FzD,EI3FC;AJ4FD,EI1FC,GAAA,CAAIA,EAAAA,EAAG;AACN,IAAA,IAAA,CAAK,IAAA,CAAKA,GAAAA,GAAK,CAAC,EAAA,GAAK,EAAA,GAAA,CAAMA,GAAAA,EAAI,EAAA,CAAA;AJ2FjC,EI1FC;AJ2FD,EIzFC,GAAA,CAAIA,EAAAA,EAAG;AACN,IAAA,OAAO,CAAC,CAAA,CAAE,IAAA,CAAK,IAAA,CAAKA,GAAAA,GAAK,CAAC,EAAA,EAAK,EAAA,GAAA,CAAMA,GAAAA,EAAI,EAAA,CAAA,CAAA;AJ0F3C,EIzFC;AACD,CAAA;ACZe,IAAM,MAAA,EAAN,MAAM,OAAM;ALuG3B,EKtGC,WAAA,CAAY,KAAA,EAAO,GAAA,EAAK,OAAA,EAAS;AAChC,IAAA,IAAA,CAAK,MAAA,EAAQ,KAAA;AACb,IAAA,IAAA,CAAK,IAAA,EAAM,GAAA;AACX,IAAA,IAAA,CAAK,SAAA,EAAW,OAAA;AAEhB,IAAA,IAAA,CAAK,MAAA,EAAQ,EAAA;AACb,IAAA,IAAA,CAAK,MAAA,EAAQ,EAAA;AAEb,IAAA,IAAA,CAAK,QAAA,EAAU,OAAA;AACf,IAAA,IAAA,CAAK,UAAA,EAAY,KAAA;AACjB,IAAA,IAAA,CAAK,OAAA,EAAS,KAAA;AAQP,IAAA;AACN,MAAA,IAAA,CAAK,SAAA,EAAW,IAAA;AAChB,MAAA,IAAA,CAAK,KAAA,EAAO,IAAA;AL8Ff,IK7FE;AL8FF,EK7FC;AL8FD,EK5FC,UAAA,CAAW,OAAA,EAAS;AACnB,IAAA,IAAA,CAAK,MAAA,GAAS,OAAA;AL6FhB,EK5FC;AL6FD,EK3FC,WAAA,CAAY,OAAA,EAAS;AACpB,IAAA,IAAA,CAAK,MAAA,EAAQ,IAAA,CAAK,MAAA,EAAQ,OAAA;AL4F5B,EK3FC;AL4FD,EK1FC,KAAA,CAAA,EAAQ;AACP,IAAA,MAAM,MAAA,EAAQ,IAAI,MAAA,CAAM,IAAA,CAAK,KAAA,EAAO,IAAA,CAAK,GAAA,EAAK,IAAA,CAAK,QAAQ,CAAA;AAE3D,IAAA,KAAA,CAAM,MAAA,EAAQ,IAAA,CAAK,KAAA;AACnB,IAAA,KAAA,CAAM,MAAA,EAAQ,IAAA,CAAK,KAAA;AACnB,IAAA,KAAA,CAAM,QAAA,EAAU,IAAA,CAAK,OAAA;AACrB,IAAA,KAAA,CAAM,UAAA,EAAY,IAAA,CAAK,SAAA;AACvB,IAAA,KAAA,CAAM,OAAA,EAAS,IAAA,CAAK,MAAA;AAEpB,IAAA,OAAO,KAAA;ALyFT,EKxFC;ALyFD,EKvFC,QAAA,CAAS,KAAA,EAAO;AACf,IAAA,OAAO,IAAA,CAAK,MAAA,EAAQ,MAAA,GAAS,MAAA,EAAQ,IAAA,CAAK,GAAA;ALwF5C,EKvFC;ALwFD,EKtFC,QAAA,CAAS,EAAA,EAAI;AACZ,IAAA,IAAI,MAAA,EAAQ,IAAA;AACZ,IAAA,MAAA,CAAO,KAAA,EAAO;AACb,MAAA,EAAA,CAAG,KAAK,CAAA;AACR,MAAA,MAAA,EAAQ,KAAA,CAAM,IAAA;ALuFjB,IKtFE;ALuFF,EKtFC;ALuFD,EKrFC,YAAA,CAAa,EAAA,EAAI;AAChB,IAAA,IAAI,MAAA,EAAQ,IAAA;AACZ,IAAA,MAAA,CAAO,KAAA,EAAO;AACb,MAAA,EAAA,CAAG,KAAK,CAAA;AACR,MAAA,MAAA,EAAQ,KAAA,CAAM,QAAA;ALsFjB,IKrFE;ALsFF,EKrFC;ALsFD,EKpFC,IAAA,CAAK,OAAA,EAAS,SAAA,EAAW,WAAA,EAAa;AACrC,IAAA,IAAA,CAAK,QAAA,EAAU,OAAA;AACf,IAAA,GAAA,CAAI,CAAC,WAAA,EAAa;AACjB,MAAA,IAAA,CAAK,MAAA,EAAQ,EAAA;AACb,MAAA,IAAA,CAAK,MAAA,EAAQ,EAAA;ALqFhB,IKpFE;AACA,IAAA,IAAA,CAAK,UAAA,EAAY,SAAA;AAEjB,IAAA,IAAA,CAAK,OAAA,EAAS,IAAA;AAEd,IAAA,OAAO,IAAA;ALmFT,EKlFC;ALmFD,EKjFC,WAAA,CAAY,OAAA,EAAS;AACpB,IAAA,IAAA,CAAK,MAAA,EAAQ,QAAA,EAAU,IAAA,CAAK,KAAA;ALkF9B,EKjFC;ALkFD,EKhFC,YAAA,CAAa,OAAA,EAAS;AACrB,IAAA,IAAA,CAAK,MAAA,EAAQ,QAAA,EAAU,IAAA,CAAK,KAAA;ALiF9B,EKhFC;ALiFD,EK/EC,KAAA,CAAA,EAAQ;AACP,IAAA,IAAA,CAAK,MAAA,EAAQ,EAAA;AACb,IAAA,IAAA,CAAK,MAAA,EAAQ,EAAA;AACb,IAAA,GAAA,CAAI,IAAA,CAAK,MAAA,EAAQ;AAChB,MAAA,IAAA,CAAK,QAAA,EAAU,IAAA,CAAK,QAAA;AACpB,MAAA,IAAA,CAAK,UAAA,EAAY,KAAA;AACjB,MAAA,IAAA,CAAK,OAAA,EAAS,KAAA;ALgFjB,IK/EE;ALgFF,EK/EC;ALgFD,EK9EC,KAAA,CAAM,KAAA,EAAO;AACZ,IAAA,MAAM,WAAA,EAAa,MAAA,EAAQ,IAAA,CAAK,KAAA;AAEhC,IAAA,MAAM,eAAA,EAAiB,IAAA,CAAK,QAAA,CAAS,KAAA,CAAM,CAAA,EAAG,UAAU,CAAA;AACxD,IAAA,MAAM,cAAA,EAAgB,IAAA,CAAK,QAAA,CAAS,KAAA,CAAM,UAAU,CAAA;AAEpD,IAAA,IAAA,CAAK,SAAA,EAAW,cAAA;AAEhB,IAAA,MAAM,SAAA,EAAW,IAAI,MAAA,CAAM,KAAA,EAAO,IAAA,CAAK,GAAA,EAAK,aAAa,CAAA;AACzD,IAAA,QAAA,CAAS,MAAA,EAAQ,IAAA,CAAK,KAAA;AACtB,IAAA,IAAA,CAAK,MAAA,EAAQ,EAAA;AAEb,IAAA,IAAA,CAAK,IAAA,EAAM,KAAA;AAEX,IAAA,GAAA,CAAI,IAAA,CAAK,MAAA,EAAQ;AAShB,MAAA,QAAA,CAAS,IAAA,CAAK,EAAA,EAAI,KAAK,CAAA;AACvB,MAAA,IAAA,CAAK,QAAA,EAAU,EAAA;ALkElB,IKjEE,EAAA,KAAO;AACN,MAAA,IAAA,CAAK,QAAA,EAAU,cAAA;ALkElB,IKjEE;AAEA,IAAA,QAAA,CAAS,KAAA,EAAO,IAAA,CAAK,IAAA;AACrB,IAAA,GAAA,CAAI,QAAA,CAAS,IAAA,EAAM,QAAA,CAAS,IAAA,CAAK,SAAA,EAAW,QAAA;AAC5C,IAAA,QAAA,CAAS,SAAA,EAAW,IAAA;AACpB,IAAA,IAAA,CAAK,KAAA,EAAO,QAAA;AAEZ,IAAA,OAAO,QAAA;ALgET,EK/DC;ALgED,EK9DC,QAAA,CAAA,EAAW;AACV,IAAA,OAAO,IAAA,CAAK,MAAA,EAAQ,IAAA,CAAK,QAAA,EAAU,IAAA,CAAK,KAAA;AL+D1C,EK9DC;AL+DD,EK7DC,OAAA,CAAQ,EAAA,EAAI;AACX,IAAA,IAAA,CAAK,MAAA,EAAQ,IAAA,CAAK,KAAA,CAAM,OAAA,CAAQ,EAAA,EAAI,EAAE,CAAA;AACtC,IAAA,GAAA,CAAI,IAAA,CAAK,KAAA,CAAM,MAAA,EAAQ,OAAO,IAAA;AAE9B,IAAA,MAAM,QAAA,EAAU,IAAA,CAAK,OAAA,CAAQ,OAAA,CAAQ,EAAA,EAAI,EAAE,CAAA;AAE3C,IAAA,GAAA,CAAI,OAAA,CAAQ,MAAA,EAAQ;AACnB,MAAA,GAAA,CAAI,QAAA,IAAY,IAAA,CAAK,OAAA,EAAS;AAC7B,QAAA,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,MAAA,EAAQ,OAAA,CAAQ,MAAM,CAAA,CAAE,IAAA,CAAK,EAAA,EAAI,KAAA,CAAA,EAAW,IAAI,CAAA;AAChE,QAAA,GAAA,CAAI,IAAA,CAAK,MAAA,EAAQ;AAEhB,UAAA,IAAA,CAAK,IAAA,CAAK,OAAA,EAAS,IAAA,CAAK,SAAA,EAAW,IAAI,CAAA;AL2D5C,QK1DI;AL2DJ,MK1DG;AACA,MAAA,OAAO,IAAA;AL2DV,IK1DE,EAAA,KAAO;AACN,MAAA,IAAA,CAAK,IAAA,CAAK,EAAA,EAAI,KAAA,CAAA,EAAW,IAAI,CAAA;AAE7B,MAAA,IAAA,CAAK,MAAA,EAAQ,IAAA,CAAK,KAAA,CAAM,OAAA,CAAQ,EAAA,EAAI,EAAE,CAAA;AACtC,MAAA,GAAA,CAAI,IAAA,CAAK,KAAA,CAAM,MAAA,EAAQ,OAAO,IAAA;AL0DjC,IKzDE;AL0DF,EKzDC;AL0DD,EKxDC,SAAA,CAAU,EAAA,EAAI;AACb,IAAA,IAAA,CAAK,MAAA,EAAQ,IAAA,CAAK,KAAA,CAAM,OAAA,CAAQ,EAAA,EAAI,EAAE,CAAA;AACtC,IAAA,GAAA,CAAI,IAAA,CAAK,KAAA,CAAM,MAAA,EAAQ,OAAO,IAAA;AAE9B,IAAA,MAAM,QAAA,EAAU,IAAA,CAAK,OAAA,CAAQ,OAAA,CAAQ,EAAA,EAAI,EAAE,CAAA;AAE3C,IAAA,GAAA,CAAI,OAAA,CAAQ,MAAA,EAAQ;AACnB,MAAA,GAAA,CAAI,QAAA,IAAY,IAAA,CAAK,OAAA,EAAS;AAC7B,QAAA,MAAM,SAAA,EAAW,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,IAAA,EAAM,OAAA,CAAQ,MAAM,CAAA;AACrD,QAAA,GAAA,CAAI,IAAA,CAAK,MAAA,EAAQ;AAEhB,UAAA,QAAA,CAAS,IAAA,CAAK,OAAA,EAAS,IAAA,CAAK,SAAA,EAAW,IAAI,CAAA;ALsDhD,QKrDI;AACA,QAAA,IAAA,CAAK,IAAA,CAAK,EAAA,EAAI,KAAA,CAAA,EAAW,IAAI,CAAA;ALsDjC,MKrDG;AACA,MAAA,OAAO,IAAA;ALsDV,IKrDE,EAAA,KAAO;AACN,MAAA,IAAA,CAAK,IAAA,CAAK,EAAA,EAAI,KAAA,CAAA,EAAW,IAAI,CAAA;AAE7B,MAAA,IAAA,CAAK,MAAA,EAAQ,IAAA,CAAK,KAAA,CAAM,OAAA,CAAQ,EAAA,EAAI,EAAE,CAAA;AACtC,MAAA,GAAA,CAAI,IAAA,CAAK,KAAA,CAAM,MAAA,EAAQ,OAAO,IAAA;ALqDjC,IKpDE;ALqDF,EKpDC;AACD,CAAA;ACrLA,SAAS,OAAA,CAAA,EAAU;AAClB,EAAA,GAAA,CAAI,OAAO,WAAA,IAAe,YAAA,GAAe,OAAO,UAAA,CAAW,KAAA,IAAS,UAAA,EAAY;AAC/E,IAAA,OAAO,CAAC,GAAA,EAAA,GAAQ,UAAA,CAAW,IAAA,CAAK,QAAA,CAAS,kBAAA,CAAmB,GAAG,CAAC,CAAC,CAAA;AN2OnE,EM1OC,EAAA,KAAA,GAAA,CAAW,OAAO,OAAA,IAAW,UAAA,EAAY;AACxC,IAAA,OAAO,CAAC,GAAA,EAAA,GAAQ,MAAA,CAAO,IAAA,CAAK,GAAA,EAAK,OAAO,CAAA,CAAE,QAAA,CAAS,QAAQ,CAAA;AN2O7D,EM1OC,EAAA,KAAO;AACN,IAAA,OAAO,CAAA,EAAA,GAAM;AACZ,MAAA,MAAM,IAAI,KAAA,CAAM,yEAAyE,CAAA;AN2O5F,IM1OE,CAAA;AN2OF,EM1OC;AACD;AAEA,IAAM,KAAA,kBAAqB,OAAA,CAAO,CAAA;AAEnB,IAAM,UAAA,EAAN,MAAgB;ANyO/B,EMxOC,WAAA,CAAY,UAAA,EAAY;AACvB,IAAA,IAAA,CAAK,QAAA,EAAU,CAAA;AACf,IAAA,IAAA,CAAK,KAAA,EAAO,UAAA,CAAW,IAAA;AACvB,IAAA,IAAA,CAAK,QAAA,EAAU,UAAA,CAAW,OAAA;AAC1B,IAAA,IAAA,CAAK,eAAA,EAAiB,UAAA,CAAW,cAAA;AACjC,IAAA,IAAA,CAAK,MAAA,EAAQ,UAAA,CAAW,KAAA;AACxB,IAAA,IAAA,CAAK,SAAA,EAAW,MAAA,CAAO,UAAA,CAAW,QAAQ,CAAA;AAC1C,IAAA,GAAA,CAAI,OAAO,UAAA,CAAW,oBAAA,IAAwB,WAAA,EAAa;AAC1D,MAAA,IAAA,CAAK,oBAAA,EAAsB,UAAA,CAAW,mBAAA;ANyOzC,IMxOE;AACA,IAAA,GAAA,CAAI,OAAO,UAAA,CAAW,QAAA,IAAY,WAAA,EAAa;AAC9C,MAAA,IAAA,CAAK,QAAA,EAAU,UAAA,CAAW,OAAA;ANyO7B,IMxOE;ANyOF,EMxOC;ANyOD,EMvOC,QAAA,CAAA,EAAW;AACV,IAAA,OAAO,IAAA,CAAK,SAAA,CAAU,IAAI,CAAA;ANwO5B,EMvOC;ANwOD,EMtOC,KAAA,CAAA,EAAQ;AACP,IAAA,OAAO,8CAAA,EAAgD,IAAA,CAAK,IAAA,CAAK,QAAA,CAAQ,CAAE,CAAA;ANuO7E,EMtOC;AACD,CAAA;ACvCe,SAAS,WAAA,CAAY,IAAA,EAAM;AACzC,EAAA,MAAM,MAAA,EAAQ,IAAA,CAAK,KAAA,CAAM,IAAI,CAAA;AAE7B,EAAA,MAAM,OAAA,EAAS,KAAA,CAAM,MAAA,CAAO,CAAC,IAAA,EAAA,GAAS,MAAA,CAAO,IAAA,CAAK,IAAI,CAAC,CAAA;AACvD,EAAA,MAAM,OAAA,EAAS,KAAA,CAAM,MAAA,CAAO,CAAC,IAAA,EAAA,GAAS,QAAA,CAAS,IAAA,CAAK,IAAI,CAAC,CAAA;AAEzD,EAAA,GAAA,CAAI,MAAA,CAAO,OAAA,IAAW,EAAA,GAAK,MAAA,CAAO,OAAA,IAAW,CAAA,EAAG;AAC/C,IAAA,OAAO,IAAA;AP6QT,EO5QC;AAKA,EAAA,GAAA,CAAI,MAAA,CAAO,OAAA,GAAU,MAAA,CAAO,MAAA,EAAQ;AACnC,IAAA,OAAO,GAAA;APyQT,EOxQC;AAGA,EAAA,MAAM,IAAA,EAAM,MAAA,CAAO,MAAA,CAAO,CAAC,QAAA,EAAU,OAAA,EAAA,GAAY;AAChD,IAAA,MAAM,UAAA,EAAY,KAAA,CAAM,IAAA,CAAK,OAAO,CAAA,CAAE,CAAC,CAAA,CAAE,MAAA;AACzC,IAAA,OAAO,IAAA,CAAK,GAAA,CAAI,SAAA,EAAW,QAAQ,CAAA;APuQrC,EOtQC,CAAA,EAAG,QAAQ,CAAA;AAEX,EAAA,OAAO,IAAI,KAAA,CAAM,IAAA,EAAM,CAAC,CAAA,CAAE,IAAA,CAAK,GAAG,CAAA;AACnC;ACxBe,SAAS,eAAA,CAAgB,IAAA,EAAM,EAAA,EAAI;AACjD,EAAA,MAAM,UAAA,EAAY,IAAA,CAAK,KAAA,CAAM,OAAO,CAAA;AACpC,EAAA,MAAM,QAAA,EAAU,EAAA,CAAG,KAAA,CAAM,OAAO,CAAA;AAEhC,EAAA,SAAA,CAAU,GAAA,CAAG,CAAA;AAEb,EAAA,MAAA,CAAO,SAAA,CAAU,CAAC,EAAA,IAAM,OAAA,CAAQ,CAAC,CAAA,EAAG;AACnC,IAAA,SAAA,CAAU,KAAA,CAAK,CAAA;AACf,IAAA,OAAA,CAAQ,KAAA,CAAK,CAAA;AR6Rf,EQ5RC;AAEA,EAAA,GAAA,CAAI,SAAA,CAAU,MAAA,EAAQ;AACrB,IAAA,IAAI,EAAA,EAAI,SAAA,CAAU,MAAA;AAClB,IAAA,MAAA,CAAO,CAAA,EAAA,EAAK,SAAA,CAAU,CAAC,EAAA,EAAI,IAAA;AR4R7B,EQ3RC;AAEA,EAAA,OAAO,SAAA,CAAU,MAAA,CAAO,OAAO,CAAA,CAAE,IAAA,CAAK,GAAG,CAAA;AAC1C;ACjBA,IAAM,SAAA,EAAW,MAAA,CAAO,SAAA,CAAU,QAAA;AAEnB,SAAS,QAAA,CAAS,KAAA,EAAO;AACvC,EAAA,OAAO,QAAA,CAAS,IAAA,CAAK,KAAK,EAAA,IAAM,iBAAA;AACjC;ACJe,SAAS,UAAA,CAAW,MAAA,EAAQ;AAC1C,EAAA,MAAM,cAAA,EAAgB,MAAA,CAAO,KAAA,CAAM,IAAI,CAAA;AACvC,EAAA,MAAM,YAAA,EAAc,CAAA,CAAA;AAEpB,EAAA,IAAA,CAAA,IAAS,EAAA,EAAI,CAAA,EAAG,IAAA,EAAM,CAAA,EAAG,EAAA,EAAI,aAAA,CAAc,MAAA,EAAQ,CAAA,EAAA,EAAK;AACvD,IAAA,WAAA,CAAY,IAAA,CAAK,GAAG,CAAA;AACpB,IAAA,IAAA,GAAO,aAAA,CAAc,CAAC,CAAA,CAAE,OAAA,EAAS,CAAA;AVgTnC,EU/SC;AAEA,EAAA,OAAO,SAAS,MAAA,CAAO,KAAA,EAAO;AAC7B,IAAA,IAAI,EAAA,EAAI,CAAA;AACR,IAAA,IAAI,EAAA,EAAI,WAAA,CAAY,MAAA;AACpB,IAAA,MAAA,CAAO,EAAA,EAAI,CAAA,EAAG;AACb,MAAA,MAAM,EAAA,EAAK,EAAA,EAAI,EAAA,GAAM,CAAA;AACrB,MAAA,GAAA,CAAI,MAAA,EAAQ,WAAA,CAAY,CAAC,CAAA,EAAG;AAC3B,QAAA,EAAA,EAAI,CAAA;AV+SR,MU9SG,EAAA,KAAO;AACN,QAAA,EAAA,EAAI,EAAA,EAAI,CAAA;AV+SZ,MU9SG;AV+SH,IU9SE;AACA,IAAA,MAAM,KAAA,EAAO,EAAA,EAAI,CAAA;AACjB,IAAA,MAAM,OAAA,EAAS,MAAA,EAAQ,WAAA,CAAY,IAAI,CAAA;AACvC,IAAA,OAAO,EAAE,IAAA,EAAM,OAAM,CAAA;AV+SvB,EU9SC,CAAA;AACD;ACxBA,IAAM,UAAA,EAAY,IAAA;AAEH,IAAM,SAAA,EAAN,MAAe;AXuU9B,EWtUC,WAAA,CAAY,KAAA,EAAO;AAClB,IAAA,IAAA,CAAK,MAAA,EAAQ,KAAA;AACb,IAAA,IAAA,CAAK,kBAAA,EAAoB,CAAA;AACzB,IAAA,IAAA,CAAK,oBAAA,EAAsB,CAAA;AAC3B,IAAA,IAAA,CAAK,IAAA,EAAM,CAAA,CAAA;AACX,IAAA,IAAA,CAAK,YAAA,EAAc,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK,iBAAiB,EAAA,EAAI,CAAA,CAAA;AACtD,IAAA,IAAA,CAAK,QAAA,EAAU,IAAA;AXuUjB,EWtUC;AXuUD,EWrUC,OAAA,CAAQ,WAAA,EAAa,OAAA,EAAS,GAAA,EAAK,SAAA,EAAW;AAC7C,IAAA,GAAA,CAAI,OAAA,CAAQ,MAAA,EAAQ;AACnB,MAAA,MAAM,sBAAA,EAAwB,OAAA,CAAQ,OAAA,EAAS,CAAA;AAC/C,MAAA,IAAI,eAAA,EAAiB,OAAA,CAAQ,OAAA,CAAQ,IAAA,EAAM,CAAC,CAAA;AAC5C,MAAA,IAAI,uBAAA,EAAyB,CAAA,CAAA;AAG7B,MAAA,MAAA,CAAO,eAAA,GAAkB,EAAA,GAAK,sBAAA,EAAwB,cAAA,EAAgB;AACrE,QAAA,MAAMC,SAAAA,EAAU,CAAC,IAAA,CAAK,mBAAA,EAAqB,WAAA,EAAa,GAAA,CAAI,IAAA,EAAM,GAAA,CAAI,MAAM,CAAA;AAC5E,QAAA,GAAA,CAAI,UAAA,GAAa,CAAA,EAAG;AACnB,UAAAA,QAAAA,CAAQ,IAAA,CAAK,SAAS,CAAA;AXoU3B,QWnUI;AACA,QAAA,IAAA,CAAK,WAAA,CAAY,IAAA,CAAKA,QAAO,CAAA;AAE7B,QAAA,IAAA,CAAK,kBAAA,GAAqB,CAAA;AAC1B,QAAA,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK,iBAAiB,EAAA,EAAI,IAAA,CAAK,YAAA,EAAc,CAAA,CAAA;AACtD,QAAA,IAAA,CAAK,oBAAA,EAAsB,CAAA;AAE3B,QAAA,uBAAA,EAAyB,cAAA;AACzB,QAAA,eAAA,EAAiB,OAAA,CAAQ,OAAA,CAAQ,IAAA,EAAM,eAAA,EAAiB,CAAC,CAAA;AXkU7D,MWjUG;AAEA,MAAA,MAAM,QAAA,EAAU,CAAC,IAAA,CAAK,mBAAA,EAAqB,WAAA,EAAa,GAAA,CAAI,IAAA,EAAM,GAAA,CAAI,MAAM,CAAA;AAC5E,MAAA,GAAA,CAAI,UAAA,GAAa,CAAA,EAAG;AACnB,QAAA,OAAA,CAAQ,IAAA,CAAK,SAAS,CAAA;AXiU1B,MWhUG;AACA,MAAA,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,OAAO,CAAA;AAE7B,MAAA,IAAA,CAAK,OAAA,CAAQ,OAAA,CAAQ,KAAA,CAAM,uBAAA,EAAyB,CAAC,CAAC,CAAA;AXgUzD,IW/TE,EAAA,KAAA,GAAA,CAAW,IAAA,CAAK,OAAA,EAAS;AACxB,MAAA,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,IAAA,CAAK,OAAO,CAAA;AAClC,MAAA,IAAA,CAAK,OAAA,CAAQ,OAAO,CAAA;AXgUvB,IW/TE;AAEA,IAAA,IAAA,CAAK,QAAA,EAAU,IAAA;AX+TjB,EW9TC;AX+TD,EW7TC,gBAAA,CAAiB,WAAA,EAAa,KAAA,EAAO,QAAA,EAAU,GAAA,EAAK,kBAAA,EAAoB;AACvE,IAAA,IAAI,kBAAA,EAAoB,KAAA,CAAM,KAAA;AAC9B,IAAA,IAAI,MAAA,EAAQ,IAAA;AAEZ,IAAA,IAAI,oBAAA,EAAsB,KAAA;AAE1B,IAAA,MAAA,CAAO,kBAAA,EAAoB,KAAA,CAAM,GAAA,EAAK;AACrC,MAAA,GAAA,CAAI,QAAA,CAAS,iBAAiB,EAAA,IAAM,IAAA,EAAM;AACzC,QAAA,GAAA,CAAI,KAAA,GAAQ,CAAA;AACZ,QAAA,GAAA,CAAI,OAAA,EAAS,CAAA;AACb,QAAA,IAAA,CAAK,kBAAA,GAAqB,CAAA;AAC1B,QAAA,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK,iBAAiB,EAAA,EAAI,IAAA,CAAK,YAAA,EAAc,CAAA,CAAA;AACtD,QAAA,IAAA,CAAK,oBAAA,EAAsB,CAAA;AAC3B,QAAA,MAAA,EAAQ,IAAA;AACR,QAAA,oBAAA,EAAsB,KAAA;AX4T1B,MW3TG,EAAA,KAAO;AACN,QAAA,GAAA,CAAI,IAAA,CAAK,MAAA,GAAS,MAAA,GAAS,kBAAA,CAAmB,GAAA,CAAI,iBAAiB,CAAA,EAAG;AACrE,UAAA,MAAM,QAAA,EAAU,CAAC,IAAA,CAAK,mBAAA,EAAqB,WAAA,EAAa,GAAA,CAAI,IAAA,EAAM,GAAA,CAAI,MAAM,CAAA;AAE5E,UAAA,GAAA,CAAI,IAAA,CAAK,MAAA,IAAU,UAAA,EAAY;AAE9B,YAAA,GAAA,CAAI,SAAA,CAAU,IAAA,CAAK,QAAA,CAAS,iBAAiB,CAAC,CAAA,EAAG;AAEhD,cAAA,GAAA,CAAI,CAAC,mBAAA,EAAqB;AACzB,gBAAA,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,OAAO,CAAA;AAC7B,gBAAA,oBAAA,EAAsB,IAAA;AXyT9B,cWxTO;AXyTP,YWxTM,EAAA,KAAO;AAEN,cAAA,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,OAAO,CAAA;AAC7B,cAAA,oBAAA,EAAsB,KAAA;AXwT7B,YWvTM;AXwTN,UWvTK,EAAA,KAAO;AACN,YAAA,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,OAAO,CAAA;AXwTnC,UWvTK;AXwTL,QWvTI;AAEA,QAAA,GAAA,CAAI,OAAA,GAAU,CAAA;AACd,QAAA,IAAA,CAAK,oBAAA,GAAuB,CAAA;AAC5B,QAAA,MAAA,EAAQ,KAAA;AXuTZ,MWtTG;AAEA,MAAA,kBAAA,GAAqB,CAAA;AXsTxB,IWrTE;AAEA,IAAA,IAAA,CAAK,QAAA,EAAU,IAAA;AXqTjB,EWpTC;AXqTD,EWnTC,OAAA,CAAQ,GAAA,EAAK;AACZ,IAAA,GAAA,CAAI,CAAC,GAAA,EAAK,MAAA;AAEV,IAAA,MAAM,MAAA,EAAQ,GAAA,CAAI,KAAA,CAAM,IAAI,CAAA;AAE5B,IAAA,GAAA,CAAI,KAAA,CAAM,OAAA,EAAS,CAAA,EAAG;AACrB,MAAA,IAAA,CAAA,IAAS,EAAA,EAAI,CAAA,EAAG,EAAA,EAAI,KAAA,CAAM,OAAA,EAAS,CAAA,EAAG,CAAA,EAAA,EAAK;AAC1C,QAAA,IAAA,CAAK,iBAAA,EAAA;AACL,QAAA,IAAA,CAAK,GAAA,CAAI,IAAA,CAAK,iBAAiB,EAAA,EAAI,IAAA,CAAK,YAAA,EAAc,CAAA,CAAA;AXkT1D,MWjTG;AACA,MAAA,IAAA,CAAK,oBAAA,EAAsB,CAAA;AXkT9B,IWjTE;AAEA,IAAA,IAAA,CAAK,oBAAA,GAAuB,KAAA,CAAM,KAAA,CAAM,OAAA,EAAS,CAAC,CAAA,CAAE,MAAA;AXiTtD,EWhTC;AACD,CAAA;ACtGA,IAAM,EAAA,EAAI,IAAA;AAEV,IAAM,OAAA,EAAS;AZuZf,EYtZC,UAAA,EAAY,KAAA;AZuZb,EYtZC,WAAA,EAAa,KAAA;AZuZd,EYtZC,SAAA,EAAW;AACZ,CAAA;AAEe,IAAM,YAAA,EAAN,MAAM,aAAY;AZsZjC,EYrZC,WAAA,CAAY,MAAA,EAAQ,QAAA,EAAU,CAAA,CAAA,EAAI;AACjC,IAAA,MAAM,MAAA,EAAQ,IAAI,KAAA,CAAM,CAAA,EAAG,MAAA,CAAO,MAAA,EAAQ,MAAM,CAAA;AAEhD,IAAA,MAAA,CAAO,gBAAA,CAAiB,IAAA,EAAM;AZqZhC,MYpZG,QAAA,EAAU,EAAE,QAAA,EAAU,IAAA,EAAM,KAAA,EAAO,OAAM,CAAA;AZqZ5C,MYpZG,KAAA,EAAO,EAAE,QAAA,EAAU,IAAA,EAAM,KAAA,EAAO,GAAE,CAAA;AZqZrC,MYpZG,KAAA,EAAO,EAAE,QAAA,EAAU,IAAA,EAAM,KAAA,EAAO,GAAE,CAAA;AZqZrC,MYpZG,UAAA,EAAY,EAAE,QAAA,EAAU,IAAA,EAAM,KAAA,EAAO,MAAK,CAAA;AZqZ7C,MYpZG,SAAA,EAAW,EAAE,QAAA,EAAU,IAAA,EAAM,KAAA,EAAO,MAAK,CAAA;AZqZ5C,MYpZG,iBAAA,EAAmB,EAAE,QAAA,EAAU,IAAA,EAAM,KAAA,EAAO,MAAK,CAAA;AZqZpD,MYpZG,OAAA,EAAS,EAAE,QAAA,EAAU,IAAA,EAAM,KAAA,EAAO,CAAA,EAAE,CAAA;AZqZvC,MYpZG,KAAA,EAAO,EAAE,QAAA,EAAU,IAAA,EAAM,KAAA,EAAO,CAAA,EAAE,CAAA;AZqZrC,MYpZG,QAAA,EAAU,EAAE,QAAA,EAAU,IAAA,EAAM,KAAA,EAAO,OAAA,CAAQ,SAAQ,CAAA;AZqZtD,MYpZG,qBAAA,EAAuB,EAAE,QAAA,EAAU,IAAA,EAAM,KAAA,EAAO,OAAA,CAAQ,sBAAqB,CAAA;AZqZhF,MYpZG,kBAAA,EAAoB,EAAE,QAAA,EAAU,IAAA,EAAM,KAAA,EAAO,IAAI,MAAA,CAAM,EAAE,CAAA;AZqZ5D,MYpZG,WAAA,EAAa,EAAE,QAAA,EAAU,IAAA,EAAM,KAAA,EAAO,CAAA,EAAE,CAAA;AZqZ3C,MYpZG,SAAA,EAAW,EAAE,QAAA,EAAU,IAAA,EAAM,KAAA,EAAO,KAAA,EAAS,CAAA;AZqZhD,MYpZG,UAAA,EAAY,EAAE,QAAA,EAAU,IAAA,EAAM,KAAA,EAAO,OAAA,CAAQ,WAAU,CAAA;AZqZ1D,MYpZG,MAAA,EAAQ,EAAE,QAAA,EAAU,IAAA,EAAM,KAAA,EAAO,OAAA,CAAQ,OAAA,GAAU,EAAC;AZqZvD,IYpZA,CAAG,CAAA;AAMD,IAAA,IAAA,CAAK,OAAA,CAAQ,CAAC,EAAA,EAAI,KAAA;AAClB,IAAA,IAAA,CAAK,KAAA,CAAM,MAAA,CAAO,MAAM,EAAA,EAAI,KAAA;AZgZ9B,EY/YC;AZgZD,EY9YC,oBAAA,CAAqB,IAAA,EAAM;AAC1B,IAAA,IAAA,CAAK,kBAAA,CAAmB,GAAA,CAAI,IAAI,CAAA;AZ+YlC,EY9YC;AZ+YD,EY7YC,MAAA,CAAO,OAAA,EAAS;AACf,IAAA,GAAA,CAAI,OAAO,QAAA,IAAY,QAAA,EAAU,MAAM,IAAI,SAAA,CAAU,gCAAgC,CAAA;AAErF,IAAA,IAAA,CAAK,MAAA,GAAS,OAAA;AACd,IAAA,OAAO,IAAA;AZ6YT,EY5YC;AZ6YD,EY3YC,UAAA,CAAW,KAAA,EAAO,OAAA,EAAS;AAC1B,IAAA,MAAA,EAAQ,MAAA,EAAQ,IAAA,CAAK,MAAA;AAErB,IAAA,GAAA,CAAI,OAAO,QAAA,IAAY,QAAA,EAAU,MAAM,IAAI,SAAA,CAAU,mCAAmC,CAAA;AAIxF,IAAA,IAAA,CAAK,MAAA,CAAO,KAAK,CAAA;AAEjB,IAAA,MAAM,MAAA,EAAQ,IAAA,CAAK,KAAA,CAAM,KAAK,CAAA;AAE9B,IAAA,GAAA,CAAI,KAAA,EAAO;AACV,MAAA,KAAA,CAAM,UAAA,CAAW,OAAO,CAAA;AZsY3B,IYrYE,EAAA,KAAO;AACN,MAAA,IAAA,CAAK,MAAA,GAAS,OAAA;AZsYjB,IYrYE;AAGA,IAAA,OAAO,IAAA;AZoYT,EYnYC;AZoYD,EYlYC,WAAA,CAAY,KAAA,EAAO,OAAA,EAAS;AAC3B,IAAA,MAAA,EAAQ,MAAA,EAAQ,IAAA,CAAK,MAAA;AAErB,IAAA,GAAA,CAAI,OAAO,QAAA,IAAY,QAAA,EAAU,MAAM,IAAI,SAAA,CAAU,mCAAmC,CAAA;AAIxF,IAAA,IAAA,CAAK,MAAA,CAAO,KAAK,CAAA;AAEjB,IAAA,MAAM,MAAA,EAAQ,IAAA,CAAK,OAAA,CAAQ,KAAK,CAAA;AAEhC,IAAA,GAAA,CAAI,KAAA,EAAO;AACV,MAAA,KAAA,CAAM,WAAA,CAAY,OAAO,CAAA;AZ6X5B,IY5XE,EAAA,KAAO;AACN,MAAA,IAAA,CAAK,MAAA,GAAS,OAAA;AZ6XjB,IY5XE;AAGA,IAAA,OAAO,IAAA;AZ2XT,EY1XC;AZ2XD,EYzXC,KAAA,CAAA,EAAQ;AACP,IAAA,MAAM,OAAA,EAAS,IAAI,YAAA,CAAY,IAAA,CAAK,QAAA,EAAU,EAAE,QAAA,EAAU,IAAA,CAAK,QAAA,EAAU,MAAA,EAAQ,IAAA,CAAK,OAAM,CAAE,CAAA;AAE9F,IAAA,IAAI,cAAA,EAAgB,IAAA,CAAK,UAAA;AACzB,IAAA,IAAI,YAAA,EAAe,MAAA,CAAO,WAAA,EAAa,MAAA,CAAO,kBAAA,EAAoB,aAAA,CAAc,KAAA,CAAK,CAAA;AAErF,IAAA,MAAA,CAAO,aAAA,EAAe;AACrB,MAAA,MAAA,CAAO,OAAA,CAAQ,WAAA,CAAY,KAAK,EAAA,EAAI,WAAA;AACpC,MAAA,MAAA,CAAO,KAAA,CAAM,WAAA,CAAY,GAAG,EAAA,EAAI,WAAA;AAEhC,MAAA,MAAM,kBAAA,EAAoB,aAAA,CAAc,IAAA;AACxC,MAAA,MAAM,gBAAA,EAAkB,kBAAA,GAAqB,iBAAA,CAAkB,KAAA,CAAK,CAAA;AAEpE,MAAA,GAAA,CAAI,eAAA,EAAiB;AACpB,QAAA,WAAA,CAAY,KAAA,EAAO,eAAA;AACnB,QAAA,eAAA,CAAgB,SAAA,EAAW,WAAA;AAE3B,QAAA,YAAA,EAAc,eAAA;AZqXlB,MYpXG;AAEA,MAAA,cAAA,EAAgB,iBAAA;AZoXnB,IYnXE;AAEA,IAAA,MAAA,CAAO,UAAA,EAAY,WAAA;AAEnB,IAAA,GAAA,CAAI,IAAA,CAAK,qBAAA,EAAuB;AAC/B,MAAA,MAAA,CAAO,sBAAA,EAAwB,IAAA,CAAK,qBAAA,CAAsB,KAAA,CAAK,CAAA;AZkXlE,IYjXE;AAEA,IAAA,MAAA,CAAO,mBAAA,EAAqB,IAAI,MAAA,CAAO,IAAA,CAAK,kBAAkB,CAAA;AAE9D,IAAA,MAAA,CAAO,MAAA,EAAQ,IAAA,CAAK,KAAA;AACpB,IAAA,MAAA,CAAO,MAAA,EAAQ,IAAA,CAAK,KAAA;AAEpB,IAAA,OAAO,MAAA;AZ+WT,EY9WC;AZ+WD,EY7WC,kBAAA,CAAmB,OAAA,EAAS;AAC3B,IAAA,QAAA,EAAU,QAAA,GAAW,CAAA,CAAA;AAErB,IAAA,MAAM,YAAA,EAAc,CAAA;AACpB,IAAA,MAAM,MAAA,EAAQ,MAAA,CAAO,IAAA,CAAK,IAAA,CAAK,WAAW,CAAA;AAC1C,IAAA,MAAM,SAAA,EAAW,IAAI,QAAA,CAAS,OAAA,CAAQ,KAAK,CAAA;AAE3C,IAAA,MAAM,OAAA,EAAS,UAAA,CAAW,IAAA,CAAK,QAAQ,CAAA;AAEvC,IAAA,GAAA,CAAI,IAAA,CAAK,KAAA,EAAO;AACf,MAAA,QAAA,CAAS,OAAA,CAAQ,IAAA,CAAK,KAAK,CAAA;AZ2W9B,IY1WE;AAEA,IAAA,IAAA,CAAK,UAAA,CAAW,QAAA,CAAS,CAAC,KAAA,EAAA,GAAU;AACnC,MAAA,MAAM,IAAA,EAAM,MAAA,CAAO,KAAA,CAAM,KAAK,CAAA;AAE9B,MAAA,GAAA,CAAI,KAAA,CAAM,KAAA,CAAM,MAAA,EAAQ,QAAA,CAAS,OAAA,CAAQ,KAAA,CAAM,KAAK,CAAA;AAEpD,MAAA,GAAA,CAAI,KAAA,CAAM,MAAA,EAAQ;AACjB,QAAA,QAAA,CAAS,OAAA;AZwWb,UYvWK,WAAA;AZwWL,UYvWK,KAAA,CAAM,OAAA;AZwWX,UYvWK,GAAA;AZwWL,UYvWK,KAAA,CAAM,UAAA,EAAY,KAAA,CAAM,OAAA,CAAQ,KAAA,CAAM,QAAQ,EAAA,EAAI,CAAA;AZwWvD,QYvWA,CAAA;AZwWA,MYvWG,EAAA,KAAO;AACN,QAAA,QAAA,CAAS,gBAAA,CAAiB,WAAA,EAAa,KAAA,EAAO,IAAA,CAAK,QAAA,EAAU,GAAA,EAAK,IAAA,CAAK,kBAAkB,CAAA;AZwW7F,MYvWG;AAEA,MAAA,GAAA,CAAI,KAAA,CAAM,KAAA,CAAM,MAAA,EAAQ,QAAA,CAAS,OAAA,CAAQ,KAAA,CAAM,KAAK,CAAA;AZuWvD,IYtWE,CAAC,CAAA;AAED,IAAA,GAAA,CAAI,IAAA,CAAK,KAAA,EAAO;AACf,MAAA,QAAA,CAAS,OAAA,CAAQ,IAAA,CAAK,KAAK,CAAA;AZsW9B,IYrWE;AAEA,IAAA,OAAO;AZqWT,MYpWG,IAAA,EAAM,OAAA,CAAQ,KAAA,EAAO,OAAA,CAAQ,IAAA,CAAK,KAAA,CAAM,OAAO,CAAA,CAAE,GAAA,CAAG,EAAA,EAAK,KAAA,CAAA;AZqW5D,MYpWG,OAAA,EAAS;AZqWZ,QYpWI,OAAA,CAAQ,OAAA,EAAS,eAAA,CAAgB,OAAA,CAAQ,KAAA,GAAQ,EAAA,EAAI,OAAA,CAAQ,MAAM,EAAA,EAAI,OAAA,CAAQ,KAAA,GAAQ;AZqW3F,MYpWA,CAAA;AZqWA,MYpWG,cAAA,EAAgB,OAAA,CAAQ,eAAA,EAAiB,CAAC,IAAA,CAAK,QAAQ,EAAA,EAAI,KAAA,CAAA;AZqW9D,MYpWG,KAAA;AZqWH,MYpWG,QAAA,EAAU,QAAA,CAAS,GAAA;AZqWtB,MYpWG,mBAAA,EAAqB,IAAA,CAAK,WAAA,EAAa,CAAC,WAAW,EAAA,EAAI,KAAA;AZqW1D,IYpWA,CAAA;AZqWA,EYpWC;AZqWD,EYnWC,WAAA,CAAY,OAAA,EAAS;AACpB,IAAA,OAAO,IAAI,SAAA,CAAU,IAAA,CAAK,kBAAA,CAAmB,OAAO,CAAC,CAAA;AZoWvD,EYnWC;AZoWD,EYlWC,gBAAA,CAAA,EAAmB;AAClB,IAAA,GAAA,CAAI,IAAA,CAAK,UAAA,IAAc,KAAA,CAAA,EAAW;AACjC,MAAA,IAAA,CAAK,UAAA,EAAY,WAAA,CAAY,IAAA,CAAK,QAAQ,CAAA;AZmW7C,IYlWE;AZmWF,EYlWC;AZmWD,EYjWC,mBAAA,CAAA,EAAsB;AACrB,IAAA,IAAA,CAAK,gBAAA,CAAgB,CAAA;AACrB,IAAA,OAAO,IAAA,CAAK,SAAA;AZkWd,EYjWC;AZkWD,EYhWC,eAAA,CAAA,EAAkB;AACjB,IAAA,IAAA,CAAK,gBAAA,CAAgB,CAAA;AACrB,IAAA,OAAO,IAAA,CAAK,UAAA,IAAc,KAAA,EAAO,IAAA,EAAO,IAAA,CAAK,SAAA;AZiW/C,EYhWC;AZiWD,EY/VC,MAAA,CAAO,SAAA,EAAW,OAAA,EAAS;AAC1B,IAAA,MAAM,QAAA,EAAU,YAAA;AAEhB,IAAA,GAAA,CAAI,QAAA,CAAS,SAAS,CAAA,EAAG;AACxB,MAAA,QAAA,EAAU,SAAA;AACV,MAAA,UAAA,EAAY,KAAA,CAAA;AZ+Vf,IY9VE;AAEA,IAAA,GAAA,CAAI,UAAA,IAAc,KAAA,CAAA,EAAW;AAC5B,MAAA,IAAA,CAAK,gBAAA,CAAgB,CAAA;AACrB,MAAA,UAAA,EAAY,IAAA,CAAK,UAAA,GAAa,GAAA;AZ8VjC,IY7VE;AAEA,IAAA,GAAA,CAAI,UAAA,IAAc,EAAA,EAAI,OAAO,IAAA;AAE7B,IAAA,QAAA,EAAU,QAAA,GAAW,CAAA,CAAA;AAGrB,IAAA,MAAM,WAAA,EAAa,CAAA,CAAA;AAEnB,IAAA,GAAA,CAAI,OAAA,CAAQ,OAAA,EAAS;AACpB,MAAA,MAAM,WAAA,EACL,OAAO,OAAA,CAAQ,OAAA,CAAQ,CAAC,EAAA,IAAM,SAAA,EAAW,CAAC,OAAA,CAAQ,OAAO,EAAA,EAAI,OAAA,CAAQ,OAAA;AACtE,MAAA,UAAA,CAAW,OAAA,CAAQ,CAAC,SAAA,EAAA,GAAc;AACjC,QAAA,IAAA,CAAA,IAAS,EAAA,EAAI,SAAA,CAAU,CAAC,CAAA,EAAG,EAAA,EAAI,SAAA,CAAU,CAAC,CAAA,EAAG,EAAA,GAAK,CAAA,EAAG;AACpD,UAAA,UAAA,CAAW,CAAC,EAAA,EAAI,IAAA;AZwVrB,QYvVI;AZwVJ,MYvVG,CAAC,CAAA;AZwVJ,IYvVE;AAEA,IAAA,IAAI,0BAAA,EAA4B,OAAA,CAAQ,YAAA,IAAgB,KAAA;AACxD,IAAA,MAAM,SAAA,EAAW,CAAC,KAAA,EAAA,GAAU;AAC3B,MAAA,GAAA,CAAI,yBAAA,EAA2B,OAAO,CAAA,EAAA;AACV,MAAA;AACrB,MAAA;AACR,IAAA;AAEyC,IAAA;AAEzB,IAAA;AACC,IAAA;AAEH,IAAA;AACK,MAAA;AAEA,MAAA;AACW,QAAA;AACG,UAAA;AAEJ,UAAA;AACG,YAAA;AAC7B,UAAA;AACD,QAAA;AACM,MAAA;AACY,QAAA;AAEM,QAAA;AACK,UAAA;AACA,YAAA;AAER,YAAA;AACU,cAAA;AACD,YAAA;AACC,cAAA;AAEG,cAAA;AACF,gBAAA;AACtB,cAAA;AACkB,gBAAA;AACV,gBAAA;AACc,gBAAA;AAC7B,cAAA;AACD,YAAA;AACD,UAAA;AAEa,UAAA;AACd,QAAA;AACD,MAAA;AAEkB,MAAA;AACJ,MAAA;AACf,IAAA;AAEyC,IAAA;AAElC,IAAA;AACR,EAAA;AAES,EAAA;AACE,IAAA;AACT,MAAA;AACH,IAAA;AACC,EAAA;AAE2B,EAAA;AACF,IAAA;AACf,MAAA;AACP,QAAA;AACJ,MAAA;AACuB,MAAA;AACrB,IAAA;AAEqC,IAAA;AACtC,EAAA;AAE4B,EAAA;AACF,IAAA;AAChB,MAAA;AACP,QAAA;AACJ,MAAA;AACwB,MAAA;AACtB,IAAA;AAEuC,IAAA;AACxC,EAAA;AAEwB,EAAA;AACF,IAAA;AACJ,IAAA;AACI,IAAA;AAEe,IAAA;AAInB,IAAA;AACF,IAAA;AACE,IAAA;AAEe,IAAA;AACL,IAAA;AAEL,IAAA;AACA,IAAA;AAEa,IAAA;AACO,IAAA;AACN,IAAA;AAER,IAAA;AACM,IAAA;AAEN,IAAA;AACM,IAAA;AAEK,IAAA;AACvB,IAAA;AACQ,MAAA;AACD,MAAA;AACvB,IAAA;AAEiB,IAAA;AACO,IAAA;AAEQ,IAAA;AACA,IAAA;AAGzB,IAAA;AACR,EAAA;AAEwC,EAAA;AAClB,IAAA;AACmB,IAAA;AACzC,EAAA;AAEqC,EAAA;AACf,IAAA;AACJ,IAAA;AAEsB,IAAA;AAEP,IAAA;AACC,MAAA;AACK,MAAA;AACtC,IAAA;AAEsC,IAAA;AACxB,IAAA;AACH,MAAA;AACT,QAAA;AACJ,MAAA;AAImB,IAAA;AACF,IAAA;AAEO,IAAA;AACE,MAAA;AACd,QAAA;AACP,UAAA;AACL,QAAA;AACuB,QAAA;AACpB,MAAA;AAE2B,MAAA;AAC5B,IAAA;AAC0C,IAAA;AACA,IAAA;AAE3B,IAAA;AACuB,MAAA;AACV,MAAA;AAChB,QAAA;AACH,QAAA;AACK,QAAA;AACZ,MAAA;AACF,IAAA;AAEgC,IAAA;AACL,IAAA;AAEhB,IAAA;AACE,MAAA;AACW,MAAA;AACU,QAAA;AACf,UAAA;AACjB,QAAA;AACc,QAAA;AACM,QAAA;AACrB,MAAA;AAEgC,MAAA;AAC1B,IAAA;AAEiC,MAAA;AAG3B,MAAA;AACQ,MAAA;AACrB,IAAA;AAGO,IAAA;AACR,EAAA;AAEiB,EAAA;AACuB,IAAA;AAEX,IAAA;AACrB,IAAA;AACR,EAAA;AAE4B,EAAA;AACN,IAAA;AAEkB,IAAA;AAItB,IAAA;AAEa,IAAA;AAEnB,IAAA;AACe,MAAA;AACnB,IAAA;AACsB,MAAA;AAC7B,IAAA;AAGO,IAAA;AACR,EAAA;AAE6B,EAAA;AACP,IAAA;AAEkB,IAAA;AAItB,IAAA;AAEe,IAAA;AAErB,IAAA;AACgB,MAAA;AACpB,IAAA;AACsB,MAAA;AAC7B,IAAA;AAGO,IAAA;AACR,EAAA;AAEmB,EAAA;AACG,IAAA;AACJ,IAAA;AAEe,IAAA;AACC,MAAA;AACK,MAAA;AACtC,IAAA;AAE0B,IAAA;AAEW,IAAA;AACJ,IAAA;AAIhB,IAAA;AACF,IAAA;AAEe,IAAA;AAEhB,IAAA;AACC,MAAA;AACA,MAAA;AACD,MAAA;AAE0B,MAAA;AACxC,IAAA;AAGO,IAAA;AACR,EAAA;AAEkB,EAAA;AACI,IAAA;AACJ,IAAA;AAEe,IAAA;AACC,MAAA;AACK,MAAA;AACtC,IAAA;AAE0B,IAAA;AAEW,IAAA;AACJ,IAAA;AAIhB,IAAA;AACF,IAAA;AAEe,IAAA;AAEhB,IAAA;AACF,MAAA;AAE4B,MAAA;AACxC,IAAA;AAGO,IAAA;AACR,EAAA;AAEW,EAAA;AAC+B,IAAA;AACxB,IAAA;AACd,IAAA;AACmC,MAAA;AACE,MAAA;AACF,MAAA;AACd,IAAA;AACiB,IAAA;AAClC,IAAA;AACR,EAAA;AAEW,EAAA;AAC8B,IAAA;AACA,IAAA;AACrB,IAAA;AACF,IAAA;AACd,IAAA;AAC0B,MAAA;AACU,QAAA;AACF,QAAA;AACX,QAAA;AACzB,MAAA;AAE8B,MAAA;AACH,QAAA;AACS,QAAA;AACT,QAAA;AAC3B,MAAA;AAE4B,MAAA;AACU,QAAA;AACF,QAAA;AACX,QAAA;AACzB,MAAA;AACuB,IAAA;AACY,IAAA;AACI,IAAA;AACpB,IAAA;AACrB,EAAA;AAEqC,EAAA;AACf,IAAA;AACJ,IAAA;AAEe,IAAA;AACC,MAAA;AACK,MAAA;AACtC,IAAA;AAEa,IAAA;AAGI,IAAA;AACuB,IAAA;AAED,MAAA;AAC9B,QAAA;AACR,MAAA;AAEc,MAAA;AACf,IAAA;AAEmC,IAAA;AAClB,MAAA;AAEE,IAAA;AACL,IAAA;AACsB,MAAA;AAClB,QAAA;AACjB,MAAA;AAEkC,MAAA;AACC,MAAA;AAClB,QAAA;AAEiB,MAAA;AACG,MAAA;AAEP,MAAA;AAEM,MAAA;AACnB,QAAA;AACjB,MAAA;AAEiB,MAAA;AAChB,QAAA;AACD,MAAA;AAEc,MAAA;AACf,IAAA;AAEO,IAAA;AACR,EAAA;AZoO4C;AYjO3B,EAAA;AACQ,IAAA;AACH,IAAA;AACkB,IAAA;AAEhC,IAAA;AACR,EAAA;AAEc,EAAA;AACyB,IAAA;AAIrB,IAAA;AACG,IAAA;AACgB,IAAA;AAEtB,IAAA;AAC0B,MAAA;AAEF,MAAA;AAGR,MAAA;AAEb,MAAA;AACjB,IAAA;AACD,EAAA;AAE0B,EAAA;AACS,IAAA;AAEK,MAAA;AAC5B,MAAA;AACT,QAAA;AACJ,MAAA;AACE,IAAA;AAEkC,IAAA;AAEd,IAAA;AACE,IAAA;AACK,IAAA;AAEQ,IAAA;AAEV,IAAA;AAElB,IAAA;AACR,EAAA;AAEW,EAAA;AACK,IAAA;AAEE,IAAA;AACH,IAAA;AACQ,MAAA;AACP,MAAA;AACf,IAAA;AAEkB,IAAA;AACnB,EAAA;AAEU,EAAA;AACQ,IAAA;AACd,IAAA;AAEkC,MAAA;AAI5B,QAAA;AACe,IAAA;AACjB,IAAA;AACR,EAAA;AAES,EAAA;AACS,IAAA;AACJ,IAAA;AACV,IAAA;AACmC,MAAA;AACd,IAAA;AACjB,IAAA;AACR,EAAA;AAEY,EAAA;AACgB,IAAA;AAC5B,EAAA;AAEe,EAAA;AAC0B,IAAA;AACzC,EAAA;AAEyB,EAAA;AACW,IAAA;AAEG,IAAA;AACR,IAAA;AAEb,IAAA;AAEd,IAAA;AACgB,MAAA;AACc,MAAA;AAGT,MAAA;AACQ,QAAA;AACN,UAAA;AACxB,QAAA;AAEwB,QAAA;AACS,QAAA;AACE,QAAA;AACpC,MAAA;AAEoB,MAAA;AACN,MAAA;AACN,IAAA;AAEF,IAAA;AACR,EAAA;AAEkB,EAAA;AACW,IAAA;AACrB,IAAA;AACR,EAAA;AAC2B,EAAA;AACe,IAAA;AAEH,IAAA;AACR,IAAA;AAEb,IAAA;AAEd,IAAA;AACgB,MAAA;AACgB,MAAA;AAEX,MAAA;AAEa,QAAA;AAEX,QAAA;AACS,QAAA;AACE,QAAA;AACpC,MAAA;AAEoB,MAAA;AACN,MAAA;AACN,IAAA;AAEF,IAAA;AACR,EAAA;AAEoB,EAAA;AACW,IAAA;AACvB,IAAA;AACR,EAAA;AAEa,EAAA;AAC0B,IAAA;AACvC,EAAA;AAEyC,EAAA;AACJ,IAAA;AACE,MAAA;AACT,QAAA;AAEJ,UAAA;AACO,UAAA;AAChB,UAAA;AACkB,UAAA;AACnB,UAAA;AACZ,QAAA;AACK,MAAA;AAC6B,QAAA;AACpC,MAAA;AACD,IAAA;AAC2B,IAAA;AACtB,MAAA;AACY,MAAA;AACe,MAAA;AACZ,QAAA;AACnB,MAAA;AACO,MAAA;AACR,IAAA;AACwB,IAAA;AACe,MAAA;AACX,MAAA;AACD,QAAA;AACJ,UAAA;AACU,UAAA;AACD,YAAA;AAC7B,UAAA;AACD,QAAA;AACA,MAAA;AACK,IAAA;AAC4B,MAAA;AACA,MAAA;AACE,QAAA;AACL,QAAA;AACK,UAAA;AACnC,QAAA;AACD,MAAA;AACD,IAAA;AACO,IAAA;AACR,EAAA;AAEoC,EAAA;AACd,IAAA;AACgB,IAAA;AAEnB,IAAA;AACsB,MAAA;AACJ,QAAA;AACnC,MAAA;AAC4B,MAAA;AACU,QAAA;AACtC,MAAA;AACD,IAAA;AAEO,IAAA;AACR,EAAA;AAEkC,EAAA;AACI,IAAA;AACT,MAAA;AAC5B,IAAA;AAEwC,IAAA;AACzC,EAAA;AAEuC,EAAA;AACjB,IAAA;AACO,IAAA;AAEQ,IAAA;AAII,MAAA;AACpB,MAAA;AACoB,MAAA;AACD,QAAA;AACtC,MAAA;AACoC,MAAA;AACrC,IAAA;AAEO,IAAA;AACR,EAAA;AAEqC,EAAA;AACC,IAAA;AACN,MAAA;AAC/B,IAAA;AAEyB,IAAA;AACd,MAAA;AACT,QAAA;AACJ,MAAA;AACE,IAAA;AAEwC,IAAA;AACzC,EAAA;AACD;AC94BoC;AAER;AACD,EAAA;AACK,IAAA;AACS,IAAA;AACxB,IAAA;AACM,IAAA;AACc,IAAA;AACpC,EAAA;AAEkB,EAAA;AACkB,IAAA;AACZ,MAAA;AACZ,QAAA;AACQ,QAAA;AACD,QAAA;AAChB,MAAA;AACF,IAAA;AAEiC,IAAA;AACtB,MAAA;AACT,QAAA;AACJ,MAAA;AACE,IAAA;AAE2B,IAAA;AACY,MAAA;AACtC,IAAA;AAEmC,IAAA;AAEX,MAAA;AACzB,IAAA;AAEqB,IAAA;AACM,MAAA;AACQ,QAAA;AACG,QAAA;AAC9B,MAAA;AACoB,QAAA;AACM,QAAA;AACf,UAAA;AACjB,QAAA;AACD,MAAA;AACD,IAAA;AAEwB,IAAA;AACjB,IAAA;AACR,EAAA;AAEqB,EAAA;AACL,IAAA;AACc,MAAA;AACG,MAAA;AAC/B,IAAA;AAEM,IAAA;AACR,EAAA;AAEQ,EAAA;AACmB,IAAA;AACb,MAAA;AACI,MAAA;AAChB,IAAA;AAEgC,IAAA;AACf,MAAA;AACC,QAAA;AACY,QAAA;AACX,QAAA;AAClB,MAAA;AACD,IAAA;AAEM,IAAA;AACR,EAAA;AAEiC,EAAA;AAClB,IAAA;AACY,IAAA;AACO,IAAA;AACM,MAAA;AACJ,QAAA;AACjC,MAAA;AACD,IAAA;AAEqC,IAAA;AAEtB,IAAA;AACY,MAAA;AAC5B,IAAA;AAEoC,IAAA;AACxB,MAAA;AACqB,QAAA;AAChC,MAAA;AAEsC,MAAA;AACX,MAAA;AACW,MAAA;AAEf,MAAA;AACY,QAAA;AACnC,MAAA;AAEiC,MAAA;AACF,QAAA;AAEG,QAAA;AAEZ,QAAA;AACF,UAAA;AACR,YAAA;AACR,cAAA;AACM,cAAA;AACN,cAAA;AACwB,cAAA;AAC/B,YAAA;AACY,UAAA;AACG,YAAA;AACR,cAAA;AACA,cAAA;AACY,cAAA;AACZ,cAAA;AACY,cAAA;AACnB,YAAA;AACK,UAAA;AACM,QAAA;AACwB,UAAA;AAC/B,QAAA;AAEiC,QAAA;AACjC,MAAA;AAEsB,MAAA;AACY,QAAA;AACnC,MAAA;AAEyB,MAAA;AACe,QAAA;AAChB,UAAA;AACvB,QAAA;AACoC,QAAA;AACrC,MAAA;AACA,IAAA;AAEM,IAAA;AAC4B,MAAA;AACD,MAAA;AACV,QAAA;AACtB,MAAA;AACsC,MAAA;AACN,QAAA;AAChC,MAAA;AACD,MAAA;AACmB,MAAA;AACnB,MAAA;AACH,IAAA;AACC,EAAA;AAEqB,EAAA;AACM,IAAA;AAC3B,EAAA;AAEkB,EAAA;AACU,IAAA;AAEM,IAAA;AACC,MAAA;AAET,MAAA;AAEY,MAAA;AACH,MAAA;AACjC,IAAA;AAGgC,IAAA;AACA,MAAA;AACvB,IAAA;AAEX,EAAA;AAEkB,EAAA;AACM,IAAA;AACU,MAAA;AACjC,IAAA;AAE6B,IAAA;AAEQ,IAAA;AAED,IAAA;AACI,MAAA;AACC,MAAA;AAEP,MAAA;AAChB,QAAA;AAChB,QAAA;Ab2gCyC;Aa1gCzC,MAAA;AAEgC,MAAA;AACjC,IAAA;AAEe,IAAA;AAGH,MAAA;AACqB,QAAA;AAC/B,MAAA;AACH,IAAA;AAEO,IAAA;AACR,EAAA;AAEa,EAAA;AACY,IAAA;AACjB,IAAA;AACR,EAAA;AAEW,EAAA;AAEK,IAAA;AAC0B,MAAA;AACA,MAAA;AAEhC,MAAA;AAEA,IAAA;AAEW,IAAA;AACrB,EAAA;AAEU,EAAA;AAC+B,IAAA;AACL,IAAA;AAC5B,IAAA;AACR,EAAA;AAES,EAAA;AACY,IAAA;AACiB,MAAA;AACzB,MAAA;AACd,IAAA;AACC,EAAA;AAEY,EAAA;AACgB,IAAA;AAC5B,EAAA;AAEe,EAAA;AAC0B,IAAA;AACzC,EAAA;AAEoB,EAAA;AACsB,IAAA;AACH,IAAA;AAErB,IAAA;AACZ,MAAA;AACI,MAAA;AAEL,MAAA;AACuB,QAAA;AACZ,QAAA;AACZ,UAAA;AACD,QAAA;AACwB,MAAA;AAC1B,IAAA;AAEO,IAAA;AACR,EAAA;AAEkB,EAAA;AACkB,IAAA;AAE/B,IAAA;AAC0B,IAAA;AAE3B,IAAA;AACuB,MAAA;AACZ,MAAA;AACwB,QAAA;AACpC,QAAA;AACD,MAAA;AACuC,IAAA;AAEjC,IAAA;AACR,EAAA;AACD;Abq/B6C;AACA;AACA;AACA;AACA","file":"/home/runner/work/ts-utilities/ts-utilities/dist/magic-string.es-2Q5FG7E2.cjs","sourcesContent":[null,"import type { StringReader, StringWriter } from './strings';\n\nexport const comma = ','.charCodeAt(0);\nexport const semicolon = ';'.charCodeAt(0);\n\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst intToChar = new Uint8Array(64); // 64 possible chars.\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\n\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\n\nexport function decodeInteger(reader: StringReader, relative: number): number {\n  let value = 0;\n  let shift = 0;\n  let integer = 0;\n\n  do {\n    const c = reader.next();\n    integer = charToInt[c];\n    value |= (integer & 31) << shift;\n    shift += 5;\n  } while (integer & 32);\n\n  const shouldNegate = value & 1;\n  value >>>= 1;\n\n  if (shouldNegate) {\n    value = -0x80000000 | -value;\n  }\n\n  return relative + value;\n}\n\nexport function encodeInteger(builder: StringWriter, num: number, relative: number): number {\n  let delta = num - relative;\n\n  delta = delta < 0 ? (-delta << 1) | 1 : delta << 1;\n  do {\n    let clamped = delta & 0b011111;\n    delta >>>= 5;\n    if (delta > 0) clamped |= 0b100000;\n    builder.write(intToChar[clamped]);\n  } while (delta > 0);\n\n  return num;\n}\n\nexport function hasMoreVlq(reader: StringReader, max: number) {\n  if (reader.pos >= max) return false;\n  return reader.peek() !== comma;\n}\n","const bufLength = 1024 * 16;\n\n// Provide a fallback for older environments.\nconst td =\n  typeof TextDecoder !== 'undefined'\n    ? /* #__PURE__ */ new TextDecoder()\n    : typeof Buffer !== 'undefined'\n      ? {\n          decode(buf: Uint8Array): string {\n            const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n            return out.toString();\n          },\n        }\n      : {\n          decode(buf: Uint8Array): string {\n            let out = '';\n            for (let i = 0; i < buf.length; i++) {\n              out += String.fromCharCode(buf[i]);\n            }\n            return out;\n          },\n        };\n\nexport class StringWriter {\n  pos = 0;\n  private out = '';\n  private buffer = new Uint8Array(bufLength);\n\n  write(v: number): void {\n    const { buffer } = this;\n    buffer[this.pos++] = v;\n    if (this.pos === bufLength) {\n      this.out += td.decode(buffer);\n      this.pos = 0;\n    }\n  }\n\n  flush(): string {\n    const { buffer, out, pos } = this;\n    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n  }\n}\n\nexport class StringReader {\n  pos = 0;\n  declare private buffer: string;\n\n  constructor(buffer: string) {\n    this.buffer = buffer;\n  }\n\n  next(): number {\n    return this.buffer.charCodeAt(this.pos++);\n  }\n\n  peek(): number {\n    return this.buffer.charCodeAt(this.pos);\n  }\n\n  indexOf(char: string): number {\n    const { buffer, pos } = this;\n    const idx = buffer.indexOf(char, pos);\n    return idx === -1 ? buffer.length : idx;\n  }\n}\n","import { comma, decodeInteger, encodeInteger, hasMoreVlq, semicolon } from './vlq';\nimport { StringWriter, StringReader } from './strings';\n\nexport {\n  decodeOriginalScopes,\n  encodeOriginalScopes,\n  decodeGeneratedRanges,\n  encodeGeneratedRanges,\n} from './scopes';\nexport type { OriginalScope, GeneratedRange, CallSite, BindingExpressionRange } from './scopes';\n\nexport type SourceMapSegment =\n  | [number]\n  | [number, number, number, number]\n  | [number, number, number, number, number];\nexport type SourceMapLine = SourceMapSegment[];\nexport type SourceMapMappings = SourceMapLine[];\n\nexport function decode(mappings: string): SourceMapMappings {\n  const { length } = mappings;\n  const reader = new StringReader(mappings);\n  const decoded: SourceMapMappings = [];\n  let genColumn = 0;\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n\n  do {\n    const semi = reader.indexOf(';');\n    const line: SourceMapLine = [];\n    let sorted = true;\n    let lastCol = 0;\n    genColumn = 0;\n\n    while (reader.pos < semi) {\n      let seg: SourceMapSegment;\n\n      genColumn = decodeInteger(reader, genColumn);\n      if (genColumn < lastCol) sorted = false;\n      lastCol = genColumn;\n\n      if (hasMoreVlq(reader, semi)) {\n        sourcesIndex = decodeInteger(reader, sourcesIndex);\n        sourceLine = decodeInteger(reader, sourceLine);\n        sourceColumn = decodeInteger(reader, sourceColumn);\n\n        if (hasMoreVlq(reader, semi)) {\n          namesIndex = decodeInteger(reader, namesIndex);\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];\n        } else {\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];\n        }\n      } else {\n        seg = [genColumn];\n      }\n\n      line.push(seg);\n      reader.pos++;\n    }\n\n    if (!sorted) sort(line);\n    decoded.push(line);\n    reader.pos = semi + 1;\n  } while (reader.pos <= length);\n\n  return decoded;\n}\n\nfunction sort(line: SourceMapSegment[]) {\n  line.sort(sortComparator);\n}\n\nfunction sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\n  return a[0] - b[0];\n}\n\nexport function encode(decoded: SourceMapMappings): string;\nexport function encode(decoded: Readonly<SourceMapMappings>): string;\nexport function encode(decoded: Readonly<SourceMapMappings>): string {\n  const writer = new StringWriter();\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0) writer.write(semicolon);\n    if (line.length === 0) continue;\n\n    let genColumn = 0;\n\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      if (j > 0) writer.write(comma);\n\n      genColumn = encodeInteger(writer, segment[0], genColumn);\n\n      if (segment.length === 1) continue;\n      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n      sourceLine = encodeInteger(writer, segment[2], sourceLine);\n      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n\n      if (segment.length === 4) continue;\n      namesIndex = encodeInteger(writer, segment[4], namesIndex);\n    }\n  }\n\n  return writer.flush();\n}\n","export default class BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}\n","export default class Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\tif (DEBUG) {\n\t\t\t// we make these non-enumerable, for sanity while debugging\n\t\t\tObject.defineProperties(this, {\n\t\t\t\tprevious: { writable: true, value: null },\n\t\t\t\tnext: { writable: true, value: null },\n\t\t\t});\n\t\t} else {\n\t\t\tthis.previous = null;\n\t\t\tthis.next = null;\n\t\t}\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\treset() {\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\t\tif (this.edited) {\n\t\t\tthis.content = this.original;\n\t\t\tthis.storeName = false;\n\t\t\tthis.edited = false;\n\t\t}\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// after split we should save the edit content record into the correct chunk\n\t\t\t// to make sure sourcemap correct\n\t\t\t// For example:\n\t\t\t// '  test'.trim()\n\t\t\t//     split   -> '  ' + 'test'\n\t\t\t//   ✔️ edit    -> '' + 'test'\n\t\t\t//   ✖️ edit    -> 'test' + ''\n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t\tif (this.edited) {\n\t\t\t\t\t// save the change, if it has been edited\n\t\t\t\t\tthis.edit(trimmed, this.storeName, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tconst newChunk = this.split(this.end - trimmed.length);\n\t\t\t\tif (this.edited) {\n\t\t\t\t\t// save the change, if it has been edited\n\t\t\t\t\tnewChunk.edit(trimmed, this.storeName, true);\n\t\t\t\t}\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n}\n","import { encode } from '@jridgewell/sourcemap-codec';\n\nfunction getBtoa() {\n\tif (typeof globalThis !== 'undefined' && typeof globalThis.btoa === 'function') {\n\t\treturn (str) => globalThis.btoa(unescape(encodeURIComponent(str)));\n\t} else if (typeof Buffer === 'function') {\n\t\treturn (str) => Buffer.from(str, 'utf-8').toString('base64');\n\t} else {\n\t\treturn () => {\n\t\t\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n\t\t};\n\t}\n}\n\nconst btoa = /*#__PURE__*/ getBtoa();\n\nexport default class SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = encode(properties.mappings);\n\t\tif (typeof properties.x_google_ignoreList !== 'undefined') {\n\t\t\tthis.x_google_ignoreList = properties.x_google_ignoreList;\n\t\t}\n\t\tif (typeof properties.debugId !== 'undefined') {\n\t\t\tthis.debugId = properties.debugId;\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n","export default function guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter((line) => /^\\t+/.test(line));\n\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n","export default function getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n","const toString = Object.prototype.toString;\n\nexport default function isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n","export default function getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n","const wordRegex = /\\w/;\n\nexport default class Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst contentLengthMinusOne = content.length - 1;\n\t\t\tlet contentLineEnd = content.indexOf('\\n', 0);\n\t\t\tlet previousContentLineEnd = -1;\n\t\t\t// Loop through each line in the content and add a segment, but stop if the last line is empty,\n\t\t\t// else code afterwards would fill one line too many\n\t\t\twhile (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {\n\t\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\t\tif (nameIndex >= 0) {\n\t\t\t\t\tsegment.push(nameIndex);\n\t\t\t\t}\n\t\t\t\tthis.rawSegments.push(segment);\n\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\n\t\t\t\tpreviousContentLineEnd = contentLineEnd;\n\t\t\t\tcontentLineEnd = content.indexOf('\\n', contentLineEnd + 1);\n\t\t\t}\n\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\n\t\t\tthis.advance(content.slice(previousContentLineEnd + 1));\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t\tthis.advance(content);\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\t\t// when iterating each char, check if it's in a word boundary\n\t\tlet charInHiresBoundary = false;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t\tcharInHiresBoundary = false;\n\t\t\t} else {\n\t\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\n\t\t\t\t\tif (this.hires === 'boundary') {\n\t\t\t\t\t\t// in hires \"boundary\", group segments per word boundary than per char\n\t\t\t\t\t\tif (wordRegex.test(original[originalCharIndex])) {\n\t\t\t\t\t\t\t// for first char in the boundary found, start the boundary by pushing a segment\n\t\t\t\t\t\t\tif (!charInHiresBoundary) {\n\t\t\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t\t\t\tcharInHiresBoundary = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// for non-word char, end the boundary by pushing a segment\n\t\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t\t\tcharInHiresBoundary = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n","import BitSet from './BitSet.js';\nimport Chunk from './Chunk.js';\nimport SourceMap from './SourceMap.js';\nimport guessIndent from './utils/guessIndent.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\nimport Stats from './utils/Stats.js';\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false,\n};\n\nexport default class MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal: { writable: true, value: string },\n\t\t\toutro: { writable: true, value: '' },\n\t\t\tintro: { writable: true, value: '' },\n\t\t\tfirstChunk: { writable: true, value: chunk },\n\t\t\tlastChunk: { writable: true, value: chunk },\n\t\t\tlastSearchedChunk: { writable: true, value: chunk },\n\t\t\tbyStart: { writable: true, value: {} },\n\t\t\tbyEnd: { writable: true, value: {} },\n\t\t\tfilename: { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations: { writable: true, value: new BitSet() },\n\t\t\tstoredNames: { writable: true, value: {} },\n\t\t\tindentStr: { writable: true, value: undefined },\n\t\t\tignoreList: { writable: true, value: options.ignoreList },\n\t\t\toffset: { writable: true, value: options.offset || 0 },\n\t\t});\n\n\t\tif (DEBUG) {\n\t\t\tObject.defineProperty(this, 'stats', { value: new Stats() });\n\t\t}\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendLeft');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendLeft');\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendRight');\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename, offset: this.offset });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext((chunk) => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\tif (this.outro) {\n\t\t\tmappings.advance(this.outro);\n\t\t}\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : undefined,\n\t\t\tsources: [\n\t\t\t\toptions.source ? getRelativePath(options.file || '', options.source) : options.file || '',\n\t\t\t],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : undefined,\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t\tx_google_ignoreList: this.ignoreList ? [sourceIndex] : undefined,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\t_ensureindentStr() {\n\t\tif (this.indentStr === undefined) {\n\t\t\tthis.indentStr = guessIndent(this.original);\n\t\t}\n\t}\n\n\t_getRawIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr;\n\t}\n\n\tgetIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tif (indentStr === undefined) {\n\t\t\tthis._ensureindentStr();\n\t\t\tindentStr = this.indentStr || '\\t';\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach((exclusion) => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = (match) => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error(\n\t\t\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)',\n\t\t);\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead',\n\t\t\t);\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead',\n\t\t\t);\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\t\tindex = index + this.offset;\n\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tif (DEBUG) this.stats.time('move');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\n\t\tif (DEBUG) this.stats.timeEnd('move');\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\toptions = options || {};\n\t\treturn this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\n\t}\n\n\tupdate(start, end, content, options) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead',\n\t\t\t);\n\n\t\tif (DEBUG) this.stats.time('overwrite');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string',\n\t\t\t\t);\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst overwrite = options !== undefined ? options.overwrite : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tObject.defineProperty(this.storedNames, original, {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: true,\n\t\t\t\tenumerable: true,\n\t\t\t});\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tlet chunk = first;\n\t\t\twhile (chunk !== last) {\n\t\t\t\tif (chunk.next !== this.byStart[chunk.end]) {\n\t\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t\t}\n\t\t\t\tchunk = chunk.next;\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, !overwrite);\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('overwrite');\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tindex = index + this.offset;\n\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tif (DEBUG) this.stats.time('remove');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('remove');\n\t\treturn this;\n\t}\n\n\treset(start, end) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tif (DEBUG) this.stats.time('reset');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.reset();\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('reset');\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length) return this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n\t\t} while ((chunk = chunk.previous));\n\t\tif (this.intro.length) return this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while ((chunk = chunk.previous));\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length - this.offset) {\n\t\tstart = start + this.offset;\n\t\tend = end + this.offset;\n\n\t\tif (this.original.length !== 0) {\n\t\t\twhile (start < 0) start += this.original.length;\n\t\t\twhile (end < 0) end += this.original.length;\n\t\t}\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tif (DEBUG) this.stats.time('_split');\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tlet previousChunk = chunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\n\t\t\t// Prevent infinite loop (e.g. via empty chunks, where start === end)\n\t\t\tif (chunk === previousChunk) return;\n\n\t\t\tpreviousChunk = chunk;\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${chunk.original}\")`,\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\tif (DEBUG) this.stats.timeEnd('_split');\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (\n\t\t\t\t(chunk.intro.length && chunk.intro.trim()) ||\n\t\t\t\t(chunk.content.length && chunk.content.trim()) ||\n\t\t\t\t(chunk.outro.length && chunk.outro.trim())\n\t\t\t)\n\t\t\t\treturn false;\n\t\t} while ((chunk = chunk.next));\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while ((chunk = chunk.next));\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n\n\thasChanged() {\n\t\treturn this.original !== this.toString();\n\t}\n\n\t_replaceRegexp(searchValue, replacement) {\n\t\tfunction getReplacement(match, str) {\n\t\t\tif (typeof replacement === 'string') {\n\t\t\t\treturn replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n\t\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\n\t\t\t\t\tif (i === '$') return '$';\n\t\t\t\t\tif (i === '&') return match[0];\n\t\t\t\t\tconst num = +i;\n\t\t\t\t\tif (num < match.length) return match[+i];\n\t\t\t\t\treturn `$${i}`;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn replacement(...match, match.index, str, match.groups);\n\t\t\t}\n\t\t}\n\t\tfunction matchAll(re, str) {\n\t\t\tlet match;\n\t\t\tconst matches = [];\n\t\t\twhile ((match = re.exec(str))) {\n\t\t\t\tmatches.push(match);\n\t\t\t}\n\t\t\treturn matches;\n\t\t}\n\t\tif (searchValue.global) {\n\t\t\tconst matches = matchAll(searchValue, this.original);\n\t\t\tmatches.forEach((match) => {\n\t\t\t\tif (match.index != null) {\n\t\t\t\t\tconst replacement = getReplacement(match, this.original);\n\t\t\t\t\tif (replacement !== match[0]) {\n\t\t\t\t\t\tthis.overwrite(match.index, match.index + match[0].length, replacement);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tconst match = this.original.match(searchValue);\n\t\t\tif (match && match.index != null) {\n\t\t\t\tconst replacement = getReplacement(match, this.original);\n\t\t\t\tif (replacement !== match[0]) {\n\t\t\t\t\tthis.overwrite(match.index, match.index + match[0].length, replacement);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t_replaceString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst index = original.indexOf(string);\n\n\t\tif (index !== -1) {\n\t\t\tif (typeof replacement === 'function') {\n\t\t\t\treplacement = replacement(string, index, original);\n\t\t\t}\n\t\t\tif (string !== replacement) {\n\t\t\t\tthis.overwrite(index, index + string.length, replacement);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplace(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceString(searchValue, replacement);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n\n\t_replaceAllString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst stringLength = string.length;\n\t\tfor (\n\t\t\tlet index = original.indexOf(string);\n\t\t\tindex !== -1;\n\t\t\tindex = original.indexOf(string, index + stringLength)\n\t\t) {\n\t\t\tconst previous = original.slice(index, index + stringLength);\n\t\t\tlet _replacement = replacement;\n\t\t\tif (typeof replacement === 'function') {\n\t\t\t\t_replacement = replacement(previous, index, original);\n\t\t\t}\n\t\t\tif (previous !== _replacement) this.overwrite(index, index + stringLength, _replacement);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplaceAll(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceAllString(searchValue, replacement);\n\t\t}\n\n\t\tif (!searchValue.global) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'MagicString.prototype.replaceAll called with a non-global RegExp argument',\n\t\t\t);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n}\n","import MagicString from './MagicString.js';\nimport SourceMap from './SourceMap.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nexport default class Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator,\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error(\n\t\t\t\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`',\n\t\t\t);\n\t\t}\n\n\t\t['filename', 'ignoreList', 'indentExclusionRanges', 'separator'].forEach((option) => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || '',\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator,\n\t\t});\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator,\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tlet x_google_ignoreList = undefined;\n\t\tthis.sources.forEach((source) => {\n\t\t\tObject.keys(source.content.storedNames).forEach((name) => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext((chunk) => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\n\t\t\tif (source.ignoreList && sourceIndex !== -1) {\n\t\t\t\tif (x_google_ignoreList === undefined) {\n\t\t\t\t\tx_google_ignoreList = [];\n\t\t\t\t}\n\t\t\t\tx_google_ignoreList.push(sourceIndex);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : undefined,\n\t\t\tsources: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t\tx_google_ignoreList,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tconst indentStr = source.content._getRawIndentString();\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart, //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty() {\n\t\tif (this.intro.length && this.intro.trim()) return false;\n\t\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce(\n\t\t\t(length, source) => length + source.content.length(),\n\t\t\tthis.intro.length,\n\t\t);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n}\n"]}