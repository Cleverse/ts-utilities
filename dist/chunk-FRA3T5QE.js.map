{"version":3,"sources":["../src/encryption/index.ts"],"sourcesContent":["import crypto from \"node:crypto\"\n\nimport VError from \"verror\"\n\n/**\n * Encryption usecase implementing AES-GCM encryption/decryption\n */\nexport class EncryptionModule {\n\t/**\n\t * Encrypts data using AES-GCM algorithm\n\t */\n\tstatic async aesGcmEncrypt(\n\t\tdata: Uint8Array,\n\t\tencryptionKey: string,\n\t\tnonce?: Uint8Array | null,\n\t): Promise<{\n\t\t/** Base64 encoded ciphertext */\n\t\tciphertext: string\n\t\t/** Nonce used for encryption */\n\t\tnonce: Uint8Array\n\t}> {\n\t\ttry {\n\t\t\t// Generate nonce if not provided\n\t\t\tconst actualNonce = nonce ?? crypto.randomBytes(12)\n\n\t\t\t// Validate encryption key length\n\t\t\tconst keyBuffer = EncryptionModule.getKeyBuffer(encryptionKey)\n\t\t\tif (keyBuffer.length !== 32) {\n\t\t\t\tthrow new VError(\"Encryption key must be exactly 32 bytes for AES-256\")\n\t\t\t}\n\n\t\t\t// Create cipher\n\t\t\tconst cipher = crypto.createCipheriv(\"aes-256-gcm\", keyBuffer, actualNonce)\n\n\t\t\t// Encrypt the data\n\t\t\tconst encrypted = Buffer.concat([cipher.update(data), cipher.final()])\n\t\t\tconst authTag = cipher.getAuthTag()\n\n\t\t\t// Combine encrypted data and auth tag\n\t\t\tconst ciphertext = Buffer.concat([encrypted, authTag])\n\n\t\t\t// Convert to base64\n\t\t\tconst base64Ciphertext = ciphertext.toString(\"base64\")\n\n\t\t\treturn {\n\t\t\t\tciphertext: base64Ciphertext,\n\t\t\t\tnonce: new Uint8Array(actualNonce),\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthrow new VError(error as Error, `Failed to encrypt data`)\n\t\t}\n\t}\n\n\t/**\n\t * Decrypts data using AES-GCM algorithm\n\t */\n\tstatic async aesGcmDecrypt(data: string, nonce: Uint8Array, encryptionKey: string): Promise<Uint8Array> {\n\t\ttry {\n\t\t\t// Validate encryption key length\n\t\t\tconst keyBuffer = EncryptionModule.getKeyBuffer(encryptionKey)\n\t\t\tif (keyBuffer.length !== 32) {\n\t\t\t\tthrow new VError(\"Encryption key must be exactly 32 bytes for AES-256\")\n\t\t\t}\n\n\t\t\t// Decode base64 data\n\t\t\tconst decodedData = Buffer.from(data, \"base64\")\n\n\t\t\t// Split ciphertext and auth tag (last 16 bytes)\n\t\t\tconst authTag = decodedData.subarray(-16)\n\t\t\tconst encrypted = decodedData.subarray(0, -16)\n\n\t\t\t// Create decipher\n\t\t\tconst decipher = crypto.createDecipheriv(\"aes-256-gcm\", keyBuffer, Buffer.from(nonce))\n\t\t\tdecipher.setAuthTag(authTag)\n\n\t\t\t// Decrypt the data\n\t\t\tconst plaintext = Buffer.concat([decipher.update(encrypted), decipher.final()])\n\n\t\t\treturn new Uint8Array(plaintext)\n\t\t} catch (error) {\n\t\t\tthrow new VError(error as Error, `Failed to decrypt data`)\n\t\t}\n\t}\n\n\t/**\n\t * Generates a random 32-character encryption key suitable for use with aesGcmEncrypt\n\t */\n\tstatic generateEncryptionKey(encoding: \"hex\" | \"base64\" | \"ascii\" | \"utf8\" = \"hex\"): string {\n\t\t// return crypto.randomBytes(16).toString(\"hex\")\n\t\tswitch (encoding) {\n\t\t\tcase \"utf8\":\n\t\t\t\t// NOTE: UTF8 fails with crypto.randomBytes(32) - non-ASCII bytes (>=128)\n\t\t\t\t// become variable-length multi-byte sequences, yielding unpredictable\n\t\t\t\t// length (e.g., 58 chars instead of 32). Use hex(16 bytes) instead.\n\t\t\t\treturn crypto.randomBytes(16).toString(\"hex\")\n\t\t\tdefault:\n\t\t\t\treturn crypto.randomBytes(32).toString(encoding)\n\t\t}\n\t}\n\n\tprivate static getKeyBuffer(key: string): Buffer {\n\t\t// Hex: 64 chars\n\t\tif (key.length === 64 && /^[0-9a-fA-F]+$/.test(key)) {\n\t\t\treturn Buffer.from(key, \"hex\")\n\t\t}\n\t\t// Base64: 44 chars (32 bytes = 42.6 chars -> 44 with padding)\n\t\tif (key.length === 44 && /^[a-zA-Z0-9+/=]+$/.test(key)) {\n\t\t\treturn Buffer.from(key, \"base64\")\n\t\t}\n\t\t// UTF-8 Fallback\n\t\treturn Buffer.from(key, \"utf8\")\n\t}\n}\n"],"mappings":";AAAA,OAAO,YAAY;AAEnB,OAAO,YAAY;AAKZ,IAAM,mBAAN,MAAM,kBAAiB;AAAA;AAAA;AAAA;AAAA,EAI7B,aAAa,cACZ,MACA,eACA,OAME;AACF,QAAI;AAEH,YAAM,cAAc,SAAS,OAAO,YAAY,EAAE;AAGlD,YAAM,YAAY,kBAAiB,aAAa,aAAa;AAC7D,UAAI,UAAU,WAAW,IAAI;AAC5B,cAAM,IAAI,OAAO,qDAAqD;AAAA,MACvE;AAGA,YAAM,SAAS,OAAO,eAAe,eAAe,WAAW,WAAW;AAG1E,YAAM,YAAY,OAAO,OAAO,CAAC,OAAO,OAAO,IAAI,GAAG,OAAO,MAAM,CAAC,CAAC;AACrE,YAAM,UAAU,OAAO,WAAW;AAGlC,YAAM,aAAa,OAAO,OAAO,CAAC,WAAW,OAAO,CAAC;AAGrD,YAAM,mBAAmB,WAAW,SAAS,QAAQ;AAErD,aAAO;AAAA,QACN,YAAY;AAAA,QACZ,OAAO,IAAI,WAAW,WAAW;AAAA,MAClC;AAAA,IACD,SAAS,OAAO;AACf,YAAM,IAAI,OAAO,OAAgB,wBAAwB;AAAA,IAC1D;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,aAAa,cAAc,MAAc,OAAmB,eAA4C;AACvG,QAAI;AAEH,YAAM,YAAY,kBAAiB,aAAa,aAAa;AAC7D,UAAI,UAAU,WAAW,IAAI;AAC5B,cAAM,IAAI,OAAO,qDAAqD;AAAA,MACvE;AAGA,YAAM,cAAc,OAAO,KAAK,MAAM,QAAQ;AAG9C,YAAM,UAAU,YAAY,SAAS,GAAG;AACxC,YAAM,YAAY,YAAY,SAAS,GAAG,GAAG;AAG7C,YAAM,WAAW,OAAO,iBAAiB,eAAe,WAAW,OAAO,KAAK,KAAK,CAAC;AACrF,eAAS,WAAW,OAAO;AAG3B,YAAM,YAAY,OAAO,OAAO,CAAC,SAAS,OAAO,SAAS,GAAG,SAAS,MAAM,CAAC,CAAC;AAE9E,aAAO,IAAI,WAAW,SAAS;AAAA,IAChC,SAAS,OAAO;AACf,YAAM,IAAI,OAAO,OAAgB,wBAAwB;AAAA,IAC1D;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,sBAAsB,WAAgD,OAAe;AAE3F,YAAQ,UAAU;AAAA,MACjB,KAAK;AAIJ,eAAO,OAAO,YAAY,EAAE,EAAE,SAAS,KAAK;AAAA,MAC7C;AACC,eAAO,OAAO,YAAY,EAAE,EAAE,SAAS,QAAQ;AAAA,IACjD;AAAA,EACD;AAAA,EAEA,OAAe,aAAa,KAAqB;AAEhD,QAAI,IAAI,WAAW,MAAM,iBAAiB,KAAK,GAAG,GAAG;AACpD,aAAO,OAAO,KAAK,KAAK,KAAK;AAAA,IAC9B;AAEA,QAAI,IAAI,WAAW,MAAM,oBAAoB,KAAK,GAAG,GAAG;AACvD,aAAO,OAAO,KAAK,KAAK,QAAQ;AAAA,IACjC;AAEA,WAAO,OAAO,KAAK,KAAK,MAAM;AAAA,EAC/B;AACD;","names":[]}