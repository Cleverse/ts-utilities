{"version":3,"sources":["../../src/kms/client.ts"],"sourcesContent":["import { KeyManagementServiceClient } from \"@google-cloud/kms\"\nimport { VError } from \"verror\"\n\nimport type { EncryptionResult, KMSClientConfig, KMSClientInterface } from \"./interfaces\"\n\n/**\n * Google Cloud KMS client for encryption and decryption operations\n */\nexport class KMSClient implements KMSClientInterface {\n\tprivate readonly client: KeyManagementServiceClient\n\tprivate readonly keyName: string\n\n\tconstructor(private readonly config: KMSClientConfig) {\n\t\tthis.client = new KeyManagementServiceClient()\n\t\tthis.keyName = this.client.cryptoKeyPath(\n\t\t\tthis.config.project,\n\t\t\tthis.config.location,\n\t\t\tthis.config.keyRing,\n\t\t\tthis.config.key,\n\t\t)\n\t}\n\n\t/**\n\t * Encrypts plaintext using Google Cloud KMS.\n\t *\n\t * The encrypt() method automatically detects key type (CryptoKey or CryptoKeyVersion) and uses the appropriate method for encryption\n\t * - `CryptoKey`: Symmetric encryption with the primary key version\n\t * - `CryptoKeyVersion`: Asymmetric encryption with public key of the specified version\n\t */\n\tasync encrypt(plaintext: string, cryptoKeyVersion?: string): Promise<EncryptionResult> {\n\t\ttry {\n\t\t\tconst keyName = cryptoKeyVersion\n\t\t\t\t? this.client.cryptoKeyVersionPath(\n\t\t\t\t\t\tthis.config.project,\n\t\t\t\t\t\tthis.config.location,\n\t\t\t\t\t\tthis.config.keyRing,\n\t\t\t\t\t\tthis.config.key,\n\t\t\t\t\t\tcryptoKeyVersion,\n\t\t\t\t\t)\n\t\t\t\t: this.keyName\n\n\t\t\tconst [encryptResponse] = await this.client.encrypt({\n\t\t\t\tname: keyName,\n\t\t\t\tplaintext: Buffer.from(plaintext),\n\t\t\t})\n\n\t\t\tif (!encryptResponse?.ciphertext || !encryptResponse.name) {\n\t\t\t\tthrow new VError(\"Not all required fields returned from KMS\")\n\t\t\t}\n\n\t\t\t// Extract crypto key version from the response name\n\t\t\tconst nameparts = encryptResponse.name.split(\"/\")\n\t\t\tcryptoKeyVersion = nameparts[nameparts.length - 1]\n\n\t\t\tif (!cryptoKeyVersion) {\n\t\t\t\tthrow new VError(\"No crypto key version returned from KMS\")\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tciphertext: Buffer.from(encryptResponse.ciphertext).toString(\"base64\"),\n\t\t\t\tcryptoKeyVersion,\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthrow new VError(error as Error, \"Failed to encrypt with KMS\")\n\t\t}\n\t}\n\n\t/**\n\t * Decrypts ciphertext using Google Cloud KMS\n\t */\n\tasync decrypt(ciphertext: string): Promise<string> {\n\t\ttry {\n\t\t\tconst ciphertextBuffer = Buffer.from(ciphertext, \"base64\")\n\t\t\tconst [decryptResponse] = await this.client.decrypt({\n\t\t\t\tname: this.keyName,\n\t\t\t\tciphertext: ciphertextBuffer,\n\t\t\t})\n\n\t\t\tif (!decryptResponse.plaintext) {\n\t\t\t\tthrow new VError(\"No plaintext returned from KMS\")\n\t\t\t}\n\n\t\t\treturn Buffer.from(decryptResponse.plaintext).toString()\n\t\t} catch (error) {\n\t\t\tthrow new VError(error as Error, \"Failed to decrypt with KMS\")\n\t\t}\n\t}\n\n\t/**\n\t * Decrypts ciphertext using Google Cloud KMS with asymmetric key\n\t * Note: Asymmetric decryption requires specifying the exact key version used for encryption\n\t */\n\tasync decryptAsymmetric(ciphertext: string, cryptoKeyVersion: string): Promise<string> {\n\t\ttry {\n\t\t\tconst ciphertextBuffer = Buffer.from(ciphertext, \"base64\")\n\n\t\t\tconst keyName = this.client.cryptoKeyVersionPath(\n\t\t\t\tthis.config.project,\n\t\t\t\tthis.config.location,\n\t\t\t\tthis.config.keyRing,\n\t\t\t\tthis.config.key,\n\t\t\t\tcryptoKeyVersion,\n\t\t\t)\n\n\t\t\tconst [decryptResponse] = await this.client.asymmetricDecrypt({\n\t\t\t\tname: keyName,\n\t\t\t\tciphertext: ciphertextBuffer,\n\t\t\t})\n\n\t\t\tif (!decryptResponse.plaintext) {\n\t\t\t\tthrow new VError(\"No plaintext returned from KMS\")\n\t\t\t}\n\n\t\t\treturn Buffer.from(decryptResponse.plaintext).toString()\n\t\t} catch (error) {\n\t\t\tthrow new VError(error as Error, \"Failed to decrypt asymmetrically with KMS\")\n\t\t}\n\t}\n\n\t/**\n\t * Closes the KMS client connection\n\t */\n\tasync close(): Promise<void> {\n\t\tawait this.client.close()\n\t}\n}\n"],"mappings":"AAAA,SAAS,kCAAkC;AAC3C,SAAS,cAAc;AAOhB,MAAM,UAAwC;AAAA,EAIpD,YAA6B,QAAyB;AAAzB;AAC5B,SAAK,SAAS,IAAI,2BAA2B;AAC7C,SAAK,UAAU,KAAK,OAAO;AAAA,MAC1B,KAAK,OAAO;AAAA,MACZ,KAAK,OAAO;AAAA,MACZ,KAAK,OAAO;AAAA,MACZ,KAAK,OAAO;AAAA,IACb;AAAA,EACD;AAAA,EAXiB;AAAA,EACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmBjB,MAAM,QAAQ,WAAmB,kBAAsD;AACtF,QAAI;AACH,YAAM,UAAU,mBACb,KAAK,OAAO;AAAA,QACZ,KAAK,OAAO;AAAA,QACZ,KAAK,OAAO;AAAA,QACZ,KAAK,OAAO;AAAA,QACZ,KAAK,OAAO;AAAA,QACZ;AAAA,MACD,IACC,KAAK;AAER,YAAM,CAAC,eAAe,IAAI,MAAM,KAAK,OAAO,QAAQ;AAAA,QACnD,MAAM;AAAA,QACN,WAAW,OAAO,KAAK,SAAS;AAAA,MACjC,CAAC;AAED,UAAI,CAAC,iBAAiB,cAAc,CAAC,gBAAgB,MAAM;AAC1D,cAAM,IAAI,OAAO,2CAA2C;AAAA,MAC7D;AAGA,YAAM,YAAY,gBAAgB,KAAK,MAAM,GAAG;AAChD,yBAAmB,UAAU,UAAU,SAAS,CAAC;AAEjD,UAAI,CAAC,kBAAkB;AACtB,cAAM,IAAI,OAAO,yCAAyC;AAAA,MAC3D;AAEA,aAAO;AAAA,QACN,YAAY,OAAO,KAAK,gBAAgB,UAAU,EAAE,SAAS,QAAQ;AAAA,QACrE;AAAA,MACD;AAAA,IACD,SAAS,OAAO;AACf,YAAM,IAAI,OAAO,OAAgB,4BAA4B;AAAA,IAC9D;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAQ,YAAqC;AAClD,QAAI;AACH,YAAM,mBAAmB,OAAO,KAAK,YAAY,QAAQ;AACzD,YAAM,CAAC,eAAe,IAAI,MAAM,KAAK,OAAO,QAAQ;AAAA,QACnD,MAAM,KAAK;AAAA,QACX,YAAY;AAAA,MACb,CAAC;AAED,UAAI,CAAC,gBAAgB,WAAW;AAC/B,cAAM,IAAI,OAAO,gCAAgC;AAAA,MAClD;AAEA,aAAO,OAAO,KAAK,gBAAgB,SAAS,EAAE,SAAS;AAAA,IACxD,SAAS,OAAO;AACf,YAAM,IAAI,OAAO,OAAgB,4BAA4B;AAAA,IAC9D;AAAA,EACD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,kBAAkB,YAAoB,kBAA2C;AACtF,QAAI;AACH,YAAM,mBAAmB,OAAO,KAAK,YAAY,QAAQ;AAEzD,YAAM,UAAU,KAAK,OAAO;AAAA,QAC3B,KAAK,OAAO;AAAA,QACZ,KAAK,OAAO;AAAA,QACZ,KAAK,OAAO;AAAA,QACZ,KAAK,OAAO;AAAA,QACZ;AAAA,MACD;AAEA,YAAM,CAAC,eAAe,IAAI,MAAM,KAAK,OAAO,kBAAkB;AAAA,QAC7D,MAAM;AAAA,QACN,YAAY;AAAA,MACb,CAAC;AAED,UAAI,CAAC,gBAAgB,WAAW;AAC/B,cAAM,IAAI,OAAO,gCAAgC;AAAA,MAClD;AAEA,aAAO,OAAO,KAAK,gBAAgB,SAAS,EAAE,SAAS;AAAA,IACxD,SAAS,OAAO;AACf,YAAM,IAAI,OAAO,OAAgB,2CAA2C;AAAA,IAC7E;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAuB;AAC5B,UAAM,KAAK,OAAO,MAAM;AAAA,EACzB;AACD;","names":[]}