{"version":3,"sources":["../../../src/utils/errors/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-ts-comment */\nimport { VError } from \"verror\"\n\nfunction unwrap(err: Error | unknown): Error | undefined {\n\tif (!err || typeof err !== \"object\" || !(\"cause\" in err)) return undefined\n\n\t// VError / NError style causes\n\tif (typeof err.cause === \"function\") {\n\t\tconst causeResult = err.cause()\n\t\treturn causeResult instanceof Error ? causeResult : undefined\n\t} else {\n\t\treturn err.cause instanceof Error ? err.cause : undefined\n\t}\n}\n\n/**\n * Finding an error of a specific type within the cause chain.\n */\nfunction findCause<T extends Error>(err: Error | unknown, reference: new (...args: any[]) => T): T | undefined {\n\tif (!(err instanceof Error)) return\n\tif (!err || !reference) return\n\tif (\n\t\t!(reference.prototype instanceof Error) &&\n\t\t// @ts-ignore\n\t\treference !== Error\n\t) {\n\t\treturn\n\t}\n\n\t// Ensures we don't go circular\n\tconst seen = new Set<Error>()\n\n\tlet _err: Error | undefined | null = err\n\twhile (_err && !seen.has(_err)) {\n\t\tseen.add(_err)\n\t\tif (_err instanceof reference) {\n\t\t\treturn _err\n\t\t}\n\n\t\t// VError.MultiError causes\n\t\tif (_err instanceof VError.MultiError) {\n\t\t\tfor (const err of _err.errors()) {\n\t\t\t\tconst result = findCause(err, reference)\n\t\t\t\tif (result) {\n\t\t\t\t\treturn result\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t_err = unwrap(_err)\n\t\t}\n\t}\n\treturn\n}\n\n/**\n * Golang-like errors utilities.\n */\nexport class errors {\n\t/**\n\t * Finding an error of a specific type within the cause chain.\n\t *\n\t * Support normal error cause (ES2021+) and VError/NError style causes\n\t */\n\tstatic find<T extends Error>(err: Error | unknown, reference: new (...args: any[]) => T): T | undefined {\n\t\treturn findCause(err, reference)\n\t}\n\n\t/**\n\t * Finding an wrapped error is a match of the reference error.\n\t * It's like `errors.Is` in Golang.\n\t *\n\t * Support normal error cause (ES2021+) and VError/NError style causes\n\t *\n\t * @example\n\t * ```ts\n\t * try {\n\t *   await someRecoverableTask().catch((err) => {\n\t *     throw new Error(\"failed to do something\", { cause: err })\n\t *   })\n\t * } catch (err: unknown) {\n\t *   // `true`\n\t *   if (errors.is(err, Error)){\n\t *     console.error(err.message) // auto type inference to `Error`\n\t *   }\n\t *\n\t *   // `true` supports to check chain of errors cause\n\t *   if (errors.is(err, RecoverableError)){\n\t *     console.error(err.message) // auto type inference to `Error`\n\t *   }\n\t * }\n\t * ```\n\t */\n\tstatic is<T extends Error>(err: Error | unknown, reference: new (...args: any[]) => T): err is Error {\n\t\treturn findCause(err, reference) !== undefined\n\t}\n\n\t/**\n\t * Checking and casting an error to a specific type.\n\t * It's like `errors.As` in Golang.\n\t *\n\t * @example\n\t * ```ts\n\t * try {\n\t *   await someRecoverableTask().catch((err) => {\n\t *     throw new HTTPError(401, \"failed to do something\")\n\t *   })\n\t * } catch (err: unknown) {\n\t *   // `true`\n\t *   if (errors.as(err, HTTPError)){\n\t *     console.error(err.code) // type inference to `HTTPError`\n\t *   }\n\t *\n\t *   // `true` because `HTTPError` is inherited from `Error`\n\t *   if (errors.as(err, Error)){\n\t *     console.error(err.message) // type inference to `Error`\n\t *   }\n\t * }\n\t * ```\n\t */\n\tstatic as<T extends Error>(err: Error | unknown, reference: new (...args: any[]) => T): err is T {\n\t\treturn err instanceof reference\n\t}\n\n\t/**\n\t * Unwrapping the error cause.\n\t *\n\t * Support normal error cause (ES2021+) and VError/NError style causes\n\t */\n\tstatic unwrap(err: Error | unknown): Error | undefined {\n\t\tif (!(err instanceof Error)) return undefined\n\t\treturn unwrap(err)\n\t}\n\n\t/**\n\t * Joining multiple errors.\n\t */\n\tstatic join(errs: Error[]): Error | null {\n\t\treturn VError.errorFromList(errs)\n\t}\n\n\tstatic toError(err: unknown): Error {\n\t\tif (err instanceof Error) return err\n\t\tif (!err) return new Error(\"Unknown error\")\n\t\treturn new Error(String(err))\n\t}\n}\n\nexport default errors\n"],"mappings":"AAEA,SAAS,cAAc;AAEvB,SAAS,OAAO,KAAyC;AACxD,MAAI,CAAC,OAAO,OAAO,QAAQ,YAAY,EAAE,WAAW,KAAM,QAAO;AAGjE,MAAI,OAAO,IAAI,UAAU,YAAY;AACpC,UAAM,cAAc,IAAI,MAAM;AAC9B,WAAO,uBAAuB,QAAQ,cAAc;AAAA,EACrD,OAAO;AACN,WAAO,IAAI,iBAAiB,QAAQ,IAAI,QAAQ;AAAA,EACjD;AACD;AAKA,SAAS,UAA2B,KAAsB,WAAqD;AAC9G,MAAI,EAAE,eAAe,OAAQ;AAC7B,MAAI,CAAC,OAAO,CAAC,UAAW;AACxB,MACC,EAAE,UAAU,qBAAqB;AAAA,EAEjC,cAAc,OACb;AACD;AAAA,EACD;AAGA,QAAM,OAAO,oBAAI,IAAW;AAE5B,MAAI,OAAiC;AACrC,SAAO,QAAQ,CAAC,KAAK,IAAI,IAAI,GAAG;AAC/B,SAAK,IAAI,IAAI;AACb,QAAI,gBAAgB,WAAW;AAC9B,aAAO;AAAA,IACR;AAGA,QAAI,gBAAgB,OAAO,YAAY;AACtC,iBAAWA,QAAO,KAAK,OAAO,GAAG;AAChC,cAAM,SAAS,UAAUA,MAAK,SAAS;AACvC,YAAI,QAAQ;AACX,iBAAO;AAAA,QACR;AAAA,MACD;AAAA,IACD,OAAO;AACN,aAAO,OAAO,IAAI;AAAA,IACnB;AAAA,EACD;AACA;AACD;AAKO,MAAM,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMnB,OAAO,KAAsB,KAAsB,WAAqD;AACvG,WAAO,UAAU,KAAK,SAAS;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA2BA,OAAO,GAAoB,KAAsB,WAAoD;AACpG,WAAO,UAAU,KAAK,SAAS,MAAM;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAyBA,OAAO,GAAoB,KAAsB,WAAgD;AAChG,WAAO,eAAe;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,OAAO,KAAyC;AACtD,QAAI,EAAE,eAAe,OAAQ,QAAO;AACpC,WAAO,OAAO,GAAG;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,KAAK,MAA6B;AACxC,WAAO,OAAO,cAAc,IAAI;AAAA,EACjC;AAAA,EAEA,OAAO,QAAQ,KAAqB;AACnC,QAAI,eAAe,MAAO,QAAO;AACjC,QAAI,CAAC,IAAK,QAAO,IAAI,MAAM,eAAe;AAC1C,WAAO,IAAI,MAAM,OAAO,GAAG,CAAC;AAAA,EAC7B;AACD;AAEA,IAAO,iBAAQ;","names":["err"]}