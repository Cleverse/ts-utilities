{"version":3,"sources":["/home/runner/work/ts-utilities/ts-utilities/dist/utils/miscellaneous/checksum.cjs","../../../src/utils/miscellaneous/checksum.ts"],"names":[],"mappings":"AAAA;AACE;AACF,4DAAiC;AACjC;AACA;ACJA,8CAAA,CAAA;AAAA,4FAAsB;AAIf,IAAM,cAAA,EAAN,MAAoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAO1B,OAAO,SAAA,CAAU,SAAA,EAA8B,IAAA,EAAsB;AACpE,IAAA,OAAO,CAAA,EAAA;AACR,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOO,EAAA;AACA,IAAA;AACF,IAAA;AACH,MAAA;AACD,IAAA;AACO,IAAA;AACR,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQO,EAAA;AACA,IAAA;AACA,IAAA;AACC,IAAA;AACR,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQO,EAAA;AACA,IAAA;AACA,IAAA;AACC,IAAA;AACR,EAAA;AACD;AAMa;AACL,EAAA;AACC,IAAA;AACR,EAAA;AACO,EAAA;AACC,IAAA;AACR,EAAA;AACD;ADJY;AACA;AACA;AACA","file":"/home/runner/work/ts-utilities/ts-utilities/dist/utils/miscellaneous/checksum.cjs","sourcesContent":[null,"import base64url from \"base64url\"\n\nexport type ChecksumAlgorithm = \"md5\" | \"crc32c\" | \"sha1\" | \"sha256\" | \"sha512\" | \"quickXorHash\"\n\nexport class ChecksumUtils {\n\t/**\n\t * Serialize the checksum into a string in the format of `{algorithm}:{hash}`\n\t * @param {ChecksumAlgorithm} algorithm - The algorithm to use\n\t * @param {string} hash - The hash to stringify\n\t * @returns The checksum string in the format of `{algorithm}:{hash}`\n\t */\n\tstatic serialize(algorithm: ChecksumAlgorithm, hash: string): string {\n\t\treturn `${algorithm}:${hash}`\n\t}\n\n\t/**\n\t * Deserialize the checksum string into algorithm and hash\n\t * @param {string} checksum - The checksum string in the format of `{algorithm}:{hash}` or `{hash}` for md5\n\t * @returns The algorithm and hash\n\t */\n\tstatic deserialize(checksum: string): { algorithm: ChecksumAlgorithm; hash: string } {\n\t\tconst parts = checksum.split(\":\")\n\t\tif (parts.length === 1) {\n\t\t\treturn { algorithm: \"md5\", hash: parts[0] ?? \"\" }\n\t\t}\n\t\treturn { algorithm: parts[0] as ChecksumAlgorithm, hash: parts[1] ?? \"\" }\n\t}\n\n\t/**\n\t * Check if the checksums can be compared (same algorithm)\n\t * @param {string} a - The first checksum\n\t * @param {string} b - The second checksum\n\t * @returns {boolean} True if the checksums can be compared\n\t */\n\tstatic canCompare(a: string, b: string): boolean {\n\t\tconst aParts = this.deserialize(a)\n\t\tconst bParts = this.deserialize(b)\n\t\treturn aParts.algorithm === bParts.algorithm\n\t}\n\n\t/**\n\t * Compare two checksums\n\t * @param {string} a - The first checksum\n\t * @param {string} b - The second checksum\n\t * @returns {boolean} True if the checksums are the same\n\t */\n\tstatic compare(a: string, b: string): boolean {\n\t\tconst aParts = this.deserialize(a)\n\t\tconst bParts = this.deserialize(b)\n\t\treturn aParts.algorithm === bParts.algorithm && aParts.hash === bParts.hash\n\t}\n}\n\n/**\n * SafeChecksum is a class that provides methods to encode and decode checksums to base64url.\n * Currently, we only support for base64 input.\n */\nexport class SafeChecksum {\n\tstatic encode(str: string): string {\n\t\treturn base64url.fromBase64(str)\n\t}\n\tstatic decode(str: string): string {\n\t\treturn base64url.toBase64(str)\n\t}\n}\n"]}