{"version":3,"sources":["../../../src/utils/aborts/index.ts"],"sourcesContent":["import { addAbortListener } from \"node:events\"\nimport { aborted } from \"node:util\"\n\nimport { delay } from \"../miscellaneous/sleep\"\n\nexport type AbortReason = Error | string | unknown\n\nexport interface RaceResult<T> {\n\tstatus: \"fulfilled\" | \"aborted\"\n\tvalue?: T\n\treason?: AbortReason\n}\n\n/**\n * Returns a promise that resolves when signal is aborted\n * Uses node:util.aborted for memory-safe implementation\n */\nexport async function awaitAbort(signal: AbortSignal, resource?: object): Promise<void> {\n\tif (signal.aborted) {\n\t\treturn Promise.resolve()\n\t}\n\treturn aborted(signal, resource ?? {})\n}\n\n/**\n * Returns a promise that rejects when signal is aborted\n */\nexport async function awaitAbortWithReject(signal: AbortSignal): Promise<never> {\n\tif (signal.aborted) {\n\t\treturn Promise.reject(getAbortReason(signal))\n\t}\n\treturn new Promise((_, reject) => {\n\t\tconst disposable = addAbortListener(signal, () => {\n\t\t\tdisposable[Symbol.dispose]()\n\t\t\treject(getAbortReason(signal))\n\t\t})\n\t})\n}\n\n/**\n * Awaits abort or timeout, returning which occurred first\n */\nexport async function awaitAbortOrTimeout(signal: AbortSignal, timeoutMs: number): Promise<\"aborted\" | \"timeout\"> {\n\treturn Promise.race([\n\t\tawaitAbort(signal).then(() => \"aborted\" as const),\n\t\tdelay(timeoutMs).then(() => \"timeout\" as const),\n\t])\n}\n\n/**\n * Races an async function against AbortSignal\n * Rejects immediately if signal is aborted during execution and returns the abort reason\n */\nexport function withAbortSignal<T>(signal: AbortSignal, asyncFn: () => Promise<T>): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst disposable = addAbortListener(signal, () => {\n\t\t\tdisposable[Symbol.dispose]()\n\t\t\treject(getAbortReason(signal))\n\t\t})\n\n\t\tasyncFn()\n\t\t\t.then(resolve)\n\t\t\t.catch(reject)\n\t\t\t.finally(() => disposable[Symbol.dispose]())\n\t})\n}\n\n/**\n * Races an async function against AbortSignal and returns result status\n * Never throws - returns structured result instead\n */\nexport async function raceWithAbort<T>(signal: AbortSignal, asyncFn: () => Promise<T>): Promise<RaceResult<T>> {\n\ttry {\n\t\tconst value = await withAbortSignal(signal, asyncFn)\n\t\treturn { status: \"fulfilled\", value }\n\t} catch (error) {\n\t\tif (error instanceof DOMException && error.name === \"AbortError\") {\n\t\t\treturn { status: \"aborted\", reason: error }\n\t\t}\n\t\tthrow error // Re-throw non-abort errors\n\t}\n}\n\n/**\n * Races multiple async functions against AbortSignal\n * Returns when first completes or signal aborts\n */\nexport function raceAllWithAbort<T>(signal: AbortSignal, asyncFns: Array<() => Promise<T>>): Promise<T> {\n\treturn withAbortSignal(signal, () => Promise.race(asyncFns.map((fn) => fn())))\n}\n\n/**\n * Creates a standard AbortError with optional reason\n */\nexport function createAbortError(reason?: AbortReason): DOMException {\n\tconst message =\n\t\treason instanceof Error ? reason.message : typeof reason === \"string\" ? reason : \"The operation was aborted\"\n\treturn new DOMException(message, \"AbortError\")\n}\n\n/**\n * Extracts abort reason from signal, creating AbortError if none exists\n */\nexport function getAbortReason(signal: AbortSignal): Error {\n\tif (signal.reason instanceof Error) {\n\t\treturn signal.reason\n\t}\n\treturn createAbortError(signal.reason)\n}\n\nconst Aborts = {\n\tawaitAbort,\n\tawaitAbortWithReject,\n\tawaitAbortOrTimeout,\n\twithAbortSignal,\n\traceWithAbort,\n\traceAllWithAbort,\n\tcreateAbortError,\n\tgetAbortReason,\n}\nexport { Aborts }\nexport default Aborts\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBAAiC;AACjC,uBAAwB;AAExB,mBAAsB;AActB,eAAsB,WAAW,QAAqB,UAAkC;AACvF,MAAI,OAAO,SAAS;AACnB,WAAO,QAAQ,QAAQ;AAAA,EACxB;AACA,aAAO,0BAAQ,QAAQ,YAAY,CAAC,CAAC;AACtC;AAKA,eAAsB,qBAAqB,QAAqC;AAC/E,MAAI,OAAO,SAAS;AACnB,WAAO,QAAQ,OAAO,eAAe,MAAM,CAAC;AAAA,EAC7C;AACA,SAAO,IAAI,QAAQ,CAAC,GAAG,WAAW;AACjC,UAAM,iBAAa,qCAAiB,QAAQ,MAAM;AACjD,iBAAW,OAAO,OAAO,EAAE;AAC3B,aAAO,eAAe,MAAM,CAAC;AAAA,IAC9B,CAAC;AAAA,EACF,CAAC;AACF;AAKA,eAAsB,oBAAoB,QAAqB,WAAmD;AACjH,SAAO,QAAQ,KAAK;AAAA,IACnB,WAAW,MAAM,EAAE,KAAK,MAAM,SAAkB;AAAA,QAChD,oBAAM,SAAS,EAAE,KAAK,MAAM,SAAkB;AAAA,EAC/C,CAAC;AACF;AAMO,SAAS,gBAAmB,QAAqB,SAAuC;AAC9F,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACvC,UAAM,iBAAa,qCAAiB,QAAQ,MAAM;AACjD,iBAAW,OAAO,OAAO,EAAE;AAC3B,aAAO,eAAe,MAAM,CAAC;AAAA,IAC9B,CAAC;AAED,YAAQ,EACN,KAAK,OAAO,EACZ,MAAM,MAAM,EACZ,QAAQ,MAAM,WAAW,OAAO,OAAO,EAAE,CAAC;AAAA,EAC7C,CAAC;AACF;AAMA,eAAsB,cAAiB,QAAqB,SAAmD;AAC9G,MAAI;AACH,UAAM,QAAQ,MAAM,gBAAgB,QAAQ,OAAO;AACnD,WAAO,EAAE,QAAQ,aAAa,MAAM;AAAA,EACrC,SAAS,OAAO;AACf,QAAI,iBAAiB,gBAAgB,MAAM,SAAS,cAAc;AACjE,aAAO,EAAE,QAAQ,WAAW,QAAQ,MAAM;AAAA,IAC3C;AACA,UAAM;AAAA,EACP;AACD;AAMO,SAAS,iBAAoB,QAAqB,UAA+C;AACvG,SAAO,gBAAgB,QAAQ,MAAM,QAAQ,KAAK,SAAS,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC;AAC9E;AAKO,SAAS,iBAAiB,QAAoC;AACpE,QAAM,UACL,kBAAkB,QAAQ,OAAO,UAAU,OAAO,WAAW,WAAW,SAAS;AAClF,SAAO,IAAI,aAAa,SAAS,YAAY;AAC9C;AAKO,SAAS,eAAe,QAA4B;AAC1D,MAAI,OAAO,kBAAkB,OAAO;AACnC,WAAO,OAAO;AAAA,EACf;AACA,SAAO,iBAAiB,OAAO,MAAM;AACtC;AAEA,MAAM,SAAS;AAAA,EACd;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACD;AAEA,IAAO,iBAAQ;","names":[]}